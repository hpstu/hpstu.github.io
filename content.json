{"meta":{"title":"hpstu`s Blog","subtitle":"hpstu","description":"C++ | Python | Ubuntu | SLAM | Deep Learning | LeetCode","author":"HP","url":"https://www.hpstu.cn","root":"/"},"pages":[{"title":"404","date":"2019-07-19T08:41:10.000Z","updated":"2022-03-24T14:47:08.506Z","comments":true,"path":"404.html","permalink":"https://www.hpstu.cn/404.html","excerpt":"","text":""},{"title":"about","date":"2020-01-01T08:41:10.000Z","updated":"2022-03-24T14:47:08.822Z","comments":true,"path":"about/index.html","permalink":"https://www.hpstu.cn/about/index.html","excerpt":"","text":"教育经历 本科 计算机科学与技术 2019/09 - 现在 努力小白 联系方式 电子邮箱 1571504536@qq.com 地址 重庆市合川区交通路593号 微信 godxiaolong QQ 1571504536"},{"title":"archives","date":"2020-01-01T08:39:20.000Z","updated":"2022-03-24T14:47:08.822Z","comments":true,"path":"archives/index.html","permalink":"https://www.hpstu.cn/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-01-01T08:39:20.000Z","updated":"2022-03-24T14:47:08.823Z","comments":true,"path":"categories/index.html","permalink":"https://www.hpstu.cn/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-01-01T09:17:02.000Z","updated":"2022-03-24T14:47:08.823Z","comments":true,"path":"contact/index.html","permalink":"https://www.hpstu.cn/contact/index.html","excerpt":"","text":"欢迎留言 大家有任何问题，都可以在评论区给我留言，或者加我联系方式： QQ：1571504536 微信：godxiaolong 我很忙啦，如果不是很麻烦的问题就直接在评论区留言啦。 当然不介意小改改加我哦~~ 友链交换 想要交换友链的小伙伴，欢迎在评论区留言，留言格式： **名称：**你的博客名称 **地址：**你的博客地址 **简介：**一句话简介 **头像：**你的头像地址 例如我的博客友链，大家可以加到自己博客里哦： **名称：**godxiaolong **地址：**https://www.yashwlon.com **简介：**Yshawlon **头像：**https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.2/Images/avatars/favicon.jpg"},{"title":"friends","date":"2020-01-01T08:42:10.000Z","updated":"2022-03-24T14:47:08.824Z","comments":true,"path":"friends/index.html","permalink":"https://www.hpstu.cn/friends/index.html","excerpt":"","text":"赞赏名单 感谢所有赞赏过我的小伙伴啦，你们的支持是我最大的动力！ panakot 友链交换 想要交换友链的小伙伴，欢迎在留言板留言，留言格式： **名称：**你的博客名称 **地址：**你的博客地址 **简介：**一句话简介 **头像：**你的头像地址 例如我的博客友链，大家可以加到自己博客里哦： **名称：**Tyzhao **地址：**https://www.muyiio.com **简介：**Yshawlon **头像：**https://cdn.jsdelivr.net/gh/MUYIio/CDN@1.2/Images/avatars/favicon.jpg"},{"title":"tags","date":"2020-01-01T08:40:27.000Z","updated":"2022-03-24T14:47:08.825Z","comments":true,"path":"tags/index.html","permalink":"https://www.hpstu.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"pdf","slug":"pdf","date":"2022-05-04T13:00:15.000Z","updated":"2022-05-04T13:34:24.337Z","comments":true,"path":"pdf.html","link":"","permalink":"https://www.hpstu.cn/pdf.html","excerpt":"","text":"ds &lt;object data=&quot;./pdf/Linux.pdf&quot;type=“application/pdf” width=“100%” height=“800px”&gt;","categories":[],"tags":[]},{"title":"python","slug":"python","date":"2022-05-01T13:22:18.000Z","updated":"2022-05-04T11:10:55.714Z","comments":true,"path":"python.html","link":"","permalink":"https://www.hpstu.cn/python.html","excerpt":"","text":"基础概念 对象 ==Python中，一切皆对象。每个对象由：标识（identity）、类型（type）、value（值）组成。== 标识用于唯一标识对象，通常对应于对象在计算机内存中的地址。使用内置函数id(obj)可返回对象obj的标识。 类型用于表示对象存储的“数据”的类型。类型可以限制对象的取值范围以及可执行的操作。可以使用type(obj)获得对象的所属类型。(类型也是对象，也有内存) 值表示对象所存储的数据的信息。使用print(obj)可以直接打印出值 引用 在Python中，变量也成为：对象的引用。因为，**变量存储的就是对象的地址。**变量通过地址引用了“对象”。 变量位于：栈内存 对象位于：堆内存 变量的声明和赋值用于将一个变量绑定到一个对象上，格式如下： 变量名=表达式 最简单的表达式就是字面量。比如：a=123。运行过程中，解释器先运行右边的表达式，生成一个代表表达式运算结果的对象；然后，将这个对象地址赋值给左边的变量。 常量 python不支持常量，即没有语法规则限制改变一个常量的值。 Python3中，int可以存储任意大小的整数。 Python仅仅对比较小的整数对象进行缓存（范围为[-5,256]）缓存起来，而并非是所有整数对象。 比较 is比较两个对象的id值是否相等，是否指向同一个内存地址； ==比较的是两个对象的内容是否相等，值是否相等； 小整数对象[-5,256]在全局解释器范围内被放入缓存供重复使用； is运算符比==效率高，在变量和None进行比较时，应该使用is。 字符串 **字符串的本质是：字符序列。**Python 的字符串是不可变的，我们无法对原字符串做任何修改。但，可以将字符串的一部分复制到新创建的字符串，达到“看起来修改”的效果。 Python不支持单字符类型，单字符也是作为一个字符串使用的。 空字符串和 len()函数 Python允许空字符串的存在，不包含任何字符且长度为 0。 len()用于计算字符串含有多少字符。例如： 12345d = &#x27;abc尚学堂&#x27;len(d)c = &#x27;&#x27; # (没有空格)len(c)# 结果为:6，0 序列 由于 Python3中一切皆对象，在内存中实际是按照如下方式存储的： 1a = [10,20,30,40] 从图示中，我们可以看出序列中存储的是整数对象的地址，而不是整数对象的值。python中常用的序列结构有： 字符串、列表、元组、字典、集合 列表 list 列表：用于存储任意数目、任意类型的数据集合。(由于列表中存储的是对象的地址，所以可以存储任意不同类型对象)，例如： 1a = [10,20,&#x27;abc&#x27;,True] 列表对象的常用方法汇总如下: Python的列表大小可变，根据需要随时增加或缩小。 字符串和列表都是序列类型，一个字符串是一个字符序列，一个列表是任何元素的序列。 列表的创建 基本语法[]创建 12a = [10,20,&#x27;gaoqi&#x27;,&#x27;sxt&#x27;]a = [] # 创建一个空的列表对象 list()创建 使用 list()可以将任何可迭代的数据转化成列表。 1234567&gt;&gt;&gt; a = list() #创建一个空的列表对象&gt;&gt;&gt; a = list(range(10))&gt;&gt;&gt; a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; a = list(&quot;gaoqi,sxt&quot;)&gt;&gt;&gt; a[&#x27;g&#x27;, &#x27;a&#x27;, &#x27;o&#x27;, &#x27;q&#x27;, &#x27;i&#x27;, &#x27;,&#x27;, &#x27;s&#x27;, &#x27;x&#x27;, &#x27;t&#x27;] 推导式生成列表 123456&gt;&gt;&gt; a = [x*2 for x in range(5)] #循环创建多个元素&gt;&gt;&gt; a[0, 2, 4, 6, 8]&gt;&gt;&gt; a = [x*2 for x in range(100) if x%9==0] #通过 if过滤元素&gt;&gt;&gt; a[0, 18, 36, 54, 72, 90, 108, 126, 144, 162, 180, 198] 元组 列表属于可变序列，可以任意修改列表中的元素。元组属于不可变序列，不能修改元组中的元素。因此，元组没有增加元素、修改元素、删除元素相关的方法。 因此，我们只需要学习元组的创建和删除，元组中元素的访问和计数即可。 元组的创建 通过()创建元组。小括号可以省略。 12a = (10,20,30) # 或者 b = 10,20,30 通过 tuple()创建元组 tuple(可迭代的对象) 1234b = tuple() #创建一个空元组对象b = tuple(&quot;abc&quot;)b = tuple(range(3))b = tuple([2,3,4]) 总结： tuple()可以接收列表、字符串、其他序列类型、迭代器等生成元组。 list() 可以接收元组、字符串、其他序列类型、迭代器等生成列表。 生成器推导式创建元组 从形式上看，生成器推导式与列表推导式类似，只是生成器推导式使用小括号。列表推导式直接生成列表对象，生成器推导式生成的不是列表也不是元组，而是一个生成器对象。我们可以通过生成器对象，转化成列表或者元组。也可以使用生成器对象的__next__()方法进行遍历，或者直接作为迭代器对象来使用。不管什么方式使用，元素访问结束后，如果需要重新访问其中的元素，必须重新创建该生成器对象。 【操作】生成器的使用测试 123456789101112131415161718&gt;&gt;&gt; s = (x*2 for x in range(5))&gt;&gt;&gt; s&lt;generator object &lt;genexpr&gt; at 0x0000000002BDEB48&gt;&gt;&gt;&gt; tuple(s)(0, 2, 4, 6, 8)&gt;&gt;&gt; list(s) #只能访问一次元素。第二次就为空了。需要再生成一次[]&gt;&gt;&gt; s&lt;generator object &lt;genexpr&gt; at 0x0000000002BDEB48&gt;&gt;&gt;&gt; tuple(s)()&gt;&gt;&gt; s = (x*2 for x in range(5))&gt;&gt;&gt; s.__next__()0&gt;&gt;&gt; s.__next__()2&gt;&gt;&gt; s.__next__()4 zip() zip(列表 1，列表 2，…)将多个列表对应位置的元素组合成为元组，并返回这个 zip对象。 123456&gt;&gt;&gt; a = [10,20,30]&gt;&gt;&gt; b = [40,50,60]&gt;&gt;&gt; c = [70,80,90]&gt;&gt;&gt; d = zip(a,b,c)&gt;&gt;&gt; list(d)[(10, 40, 70), (20, 50, 80), (30, 60, 90)] 元组总结 元组的核心特点是：不可变序列。 元组的访问和处理速度比列表快。 与整数和字符串一样，元组可以作为字典的键，列表则永远不能作为字典的键使用。 字典 字典是**“键值对”的无序可变序列，字典中的每个元素都是一个“键值对”，包含：“键对象”和“值对象”。可以通过“键对象”实现快速获取、删除、更新对应的“值对象”。列表中我们通过“下标数字”找到对应的对象。字典中通过“键对象”找到对应的“值对象”。“键”是任意的不可变数据**，比如：整数、浮点数、字符串、元组。但是：列表、字典、集合这些可变对象，不能作为“键”。并且“键”不可重复。“值”可以是任意的数据，并且可重复。 字典的创建 通过{}、dict()来创建字典对象。 12345&gt;&gt;&gt; a = &#123;&#x27;name&#x27;:&#x27;gaoqi&#x27;,&#x27;age&#x27;:18,&#x27;job&#x27;:&#x27;programmer&#x27;&#125;&gt;&gt;&gt; b = dict(name=&#x27;gaoqi&#x27;,age=18,job=&#x27;programmer&#x27;)&gt;&gt;&gt; a = dict([(&quot;name&quot;,&quot;gaoqi&quot;),(&quot;age&quot;,18)])&gt;&gt;&gt; c = &#123;&#125; #空的字典对象&gt;&gt;&gt; d = dict() #空的字典对象 通过 zip()创建字典对象 12345&gt;&gt;&gt; k = [&#x27;name&#x27;,&#x27;age&#x27;,&#x27;job&#x27;]&gt;&gt;&gt; v = [&#x27;gaoqi&#x27;,18,&#x27;techer&#x27;]&gt;&gt;&gt; d = dict(zip(k,v))&gt;&gt;&gt; d&#123;&#x27;name&#x27;: &#x27;gaoqi&#x27;, &#x27;age&#x27;: 18, &#x27;job&#x27;: &#x27;techer&#x27;&#125; 通过 fromkeys创建值为空的字典 123&gt;&gt;&gt; a = dict.fromkeys([&#x27;name&#x27;,&#x27;age&#x27;,&#x27;job&#x27;])&gt;&gt;&gt; a&#123;&#x27;name&#x27;: None, &#x27;age&#x27;: None, &#x27;job&#x27;: None&#125; 字典元素的访问 为了测试各种访问方法，我们这里设定一个字典对象： 1a = &#123;&#x27;name&#x27;:&#x27;gaoqi&#x27;,&#x27;age&#x27;:18,&#x27;job&#x27;:&#x27;programmer&#x27;&#125; 通过 [键] 获得“值”。若键不存在，则抛出异常。 12345678910&gt;&gt;&gt; a = &#123;&#x27;name&#x27;:&#x27;gaoqi&#x27;,&#x27;age&#x27;:18,&#x27;job&#x27;:&#x27;programmer&#x27;&#125;&gt;&gt;&gt; a[&#x27;name&#x27;]&#x27;gaoqi&#x27;&gt;&gt;&gt; a[&#x27;age&#x27;]18&gt;&gt;&gt; a[&#x27;sex&#x27;]Traceback (most recent call last):File &quot;&lt;pyshell#374&gt;&quot;, line 1, in &lt;module&gt;a[&#x27;sex&#x27;]KeyError: &#x27;sex&#x27; 通过get()方法获得“值”。推荐使用。优点是：指定键不存在，返回None；也可以设定指定键不存在时默认返回的对象。推荐使用get()获取“值对象”。 12345&gt;&gt;&gt; a.get(&#x27;name&#x27;)&#x27;gaoqi&#x27;&gt;&gt;&gt; a.get(&#x27;sex&#x27;)&gt;&gt;&gt; a.get(&#x27;sex&#x27;,&#x27;一个男人&#x27;)&#x27;一个男人&#x27; 列出所有的键值对 12&gt;&gt;&gt; a.items()dict_items([(&#x27;name&#x27;, &#x27;gaoqi&#x27;), (&#x27;age&#x27;, 18), (&#x27;job&#x27;, &#x27;programmer&#x27;)]) 列出所有的键，列出所有的值 1234&gt;&gt;&gt; a.keys()dict_keys([&#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;])&gt;&gt;&gt; a.values()dict_values([&#x27;gaoqi&#x27;, 18, &#x27;programmer&#x27;]) len()键值对的个数 检测一个“键”是否在字典中 123&gt;&gt;&gt; a = &#123;&quot;name&quot;:&quot;gaoqi&quot;,&quot;age&quot;:18&#125;&gt;&gt;&gt; &quot;name&quot; in aTrue 控制语句 函数 面向对象 文件","categories":[{"name":"python","slug":"python","permalink":"https://www.hpstu.cn/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"https://www.hpstu.cn/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"clion","slug":"clion","date":"2022-04-27T09:26:47.000Z","updated":"2022-05-01T13:10:39.423Z","comments":true,"path":"clion.html","link":"","permalink":"https://www.hpstu.cn/clion.html","excerpt":"","text":"快捷键 快捷键 备注 Ctrl + / 注释(取消注释)选择的行 Ctrl + Shift + / 块注释 Ctrl + Shift + F 高级查找 Ctrl + D 复制当前行、或者选择的块 Alt + Shift + Click 将插入符号放置在多个位置 CTRL+ALT+I 自动缩进 Ctrl + P 参数信息（在方法中调用参数） Alt + Enter 快速修正（给出提示信息） Ctrl + Alt + L 代码格式化 运行类 Alt + Shift + F10 运行模式配置 Alt + Shift + F9 调试模式配置 Shift + F10 运行 Shift + F9 调试 导航类 Ctrl+B / Ctrl+Click 跳转到声明 Ctrl + Alt + B 跳转到定义 Ctrl + Shift + I 查看快速定义 Ctrl + Shift + B 跳转到类型声明 Ctrl + ] / Ctrl + [ 跳转到代码块结束、开始 查找、替换类 Ctrl + R 替换 Ctrl + F 查找 Ctrl + Shift + F 全局文件查找内容 Ctrl + Shift + R 全局替换 连击两次 Shift 全局查找文件 重构类 Shift + F6 重命名 Ctrl + E 最近打开的文件","categories":[{"name":"软件工具","slug":"软件工具","permalink":"https://www.hpstu.cn/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"clion","slug":"clion","permalink":"https://www.hpstu.cn/tags/clion/"}]},{"title":"C++STL","slug":"CSTL","date":"2022-04-19T04:21:17.000Z","updated":"2022-05-01T13:11:00.595Z","comments":true,"path":"cstl.html","link":"","permalink":"https://www.hpstu.cn/cstl.html","excerpt":"","text":"","categories":[{"name":"C++","slug":"C","permalink":"https://www.hpstu.cn/categories/C/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.hpstu.cn/tags/STL/"}]},{"title":"g2o","slug":"g2o","date":"2022-03-26T13:07:01.000Z","updated":"2022-05-01T13:14:01.093Z","comments":true,"path":"g2o.html","link":"","permalink":"https://www.hpstu.cn/g2o.html","excerpt":"","text":"G2O Example 最小化重投影误差求解PnP 像素点与空间点位置关系： siui=KTPis_iu_i=KTP_i s​i​​u​i​​=KTP​i​​ 其中：sis_is​i​​：相机坐标系下点的深度，uiu_iu​i​​：点的像素坐标，KKK：相机内参，TTT：相机位姿，PiP_iP​i​​：世界坐标系下的点的坐标 误差关系： e=ui−1siKTPie=u_i-\\frac{1}{s_i}KTP_i e=u​i​​−​s​i​​​​1​​KTP​i​​ 优化关系： T^{\\star} = \\underset{T}{arg\\,min}\\frac{1}{2}\\sum\\limits_{i=1}^n||u_i-\\frac{1}{s_i}KTP_i|| 最小二乘问题 \\underset{x}{min}F(x)=\\frac{1}{2}||f(x)||^2_2 一阶和二阶梯度法 考虑第kkk次迭代，将F(x)F(x)F(x)进行展开： F(xk+δxk)≈F(x)+J(xk)Tδxk+12δxkTH(xk)δxkF(x_k+\\delta x_k)\\approx F(x)+J(x_k)^T\\delta x_k+\\frac{1}{2}\\delta x_k^TH(x_k)\\delta x_k F(x​k​​+δx​k​​)≈F(x)+J(x​k​​)​T​​δx​k​​+​2​​1​​δx​k​T​​H(x​k​​)δx​k​​ 其中：J(xk)J(x_k)J(x​k​​)是关于F(x)F(x)F(x)的一阶导数（梯度），HHH为二阶导数。 。。。。。。 高斯牛顿法： 将f(x)f(x)f(x)进行展开： f(x+δx)≈f(x)+J(x)Tδxf(x+\\delta x)\\approx f(x)+J(x)^T\\delta x f(x+δx)≈f(x)+J(x)​T​​δx … 得到如下方程组： J(x)J(x)Tδx=−J(x)f(x)J(x)J(x)^T\\delta x=-J(x)f(x) J(x)J(x)​T​​δx=−J(x)f(x) 亦即： Hδx=gH\\delta x = g Hδx=g e(x+δx)≈e(x)+JTδxe(x+\\delta x)\\approx e(x)+J^T\\delta x e(x+δx)≈e(x)+J​T​​δx 在g2o中， 顶点要做的就是实现加法， 边要做的就是要实现e的计算以及JJJ 顶点的定义 继承BaseVertex&lt;顶点维度, 顶点结构体&gt; 实现setToOriginImpl()override函数，里面给_estimate成员赋初值(_estimate 的类型就是模板里指定的顶点结构体) 实现oplusImpl(const double* update)override函数，update是指向更新值的指针（实现加法更新运算）使用前需要转换成真实的结构类型。不一定是顶点类型。比如update可以是李代数，但顶点类型是李群。 可以使用esitimate()函数得到顶点的值，类型同上面的顶点结构体。 123456789101112131415161718class VertexPose : public g2o::BaseVertex&lt;6, Sophus::SE3d&gt; &#123;public: EIGEN_MAKE_ALIGNED_OPERATOR_NEW;// 初始化估计值 virtual void setToOriginImpl() override &#123; _estimate = Sophus::SE3d(); // 使用模板中声明的类型初始化 &#125; /// 加法运算（更新估计） virtual void oplusImpl(const double *update) override &#123; Eigen::Matrix&lt;double, 6, 1&gt; update_eigen; update_eigen &lt;&lt; update[0], update[1], update[2], update[3], update[4], update[5]; _estimate = Sophus::SE3d::exp(update_eigen) * _estimate; // 使用定义的加法 &#125;// 读写操作 virtual bool read(istream &amp;in) override &#123;&#125; virtual bool write(ostream &amp;out) const override &#123;&#125;&#125;; 边的定义 继承BaseBinaryEdge&lt;观测值维度，观测值结构体，第一个顶点的类型，第二个顶点的类型&gt; // 二元边 或继承BaseUnaryEdge&lt;观测值维度，观测值结构体，顶点的类型&gt; // 一元边 实现函数computeError()override,函数里面需要计算_error的值（使用误差公式，即利用观测值减去顶点的观测模型的预测值） 实现linearizeOplus()override，单顶点的计算_jacobianOplusXi矩阵，双顶点的还要计算_jacobianOplusXj矩阵 123456789101112131415161718192021222324252627282930313233343536373839class EdgeProjection : public g2o::BaseUnaryEdge&lt;2, Eigen::Vector2d, VertexPose&gt; &#123;public: EIGEN_MAKE_ALIGNED_OPERATOR_NEW; EdgeProjection(const Eigen::Vector3d &amp;pos, const Eigen::Matrix3d &amp;K) : _pos3d(pos), _K(K) &#123;&#125;// 计算误差 virtual void computeError() override &#123; const VertexPose *v = static_cast&lt;VertexPose *&gt; (_vertices[0]); Sophus::SE3d T = v-&gt;estimate(); Eigen::Vector3d pos_pixel = _K * (T * _pos3d); pos_pixel /= pos_pixel[2]; _error = _measurement - pos_pixel.head&lt;2&gt;(); &#125;// 计算雅可比矩阵 virtual void linearizeOplus() override &#123; const VertexPose *v = static_cast&lt;VertexPose *&gt; (_vertices[0]); Sophus::SE3d T = v-&gt;estimate(); Eigen::Vector3d pos_cam = T * _pos3d; double fx = _K(0, 0); double fy = _K(1, 1); double cx = _K(0, 2); double cy = _K(1, 2); double X = pos_cam[0]; double Y = pos_cam[1]; double Z = pos_cam[2]; double Z2 = Z * Z; _jacobianOplusXi &lt;&lt; -fx / Z, 0, fx * X / Z2, fx * X * Y / Z2, -fx - fx * X * X / Z2, fx * Y / Z, 0, -fy / Z, fy * Y / (Z * Z), fy + fy * Y * Y / Z2, -fy * X * Y / Z2, -fy * X / Z; &#125; virtual bool read(istream &amp;in) override &#123;&#125; virtual bool write(ostream &amp;out) const override &#123;&#125;private: Eigen::Vector3d _pos3d; Eigen::Matrix3d _K;&#125;; SparseOptimizer 这个应该是总的流程和数据管理器 setAlgorithm设置具体计算更新值得算法 addVertex加入顶点 addEdge() addParameter()可以传入一些超参 initializeOptimization()给顶点填入初始值 optimize()启动优化流程: 调用所有边的linearizeOplus()函数，得到每个边的雅克比矩阵，然后把矩阵连接成一个大矩阵 调用所有边的computeError()，得到误差矩阵 基于雅克比和误差，使用优化器计算更新值（矩阵求逆，主要时间花费在这里） 把拆分成各个顶点的值 调用顶点的oplusImpl函数，更新顶点的_estimate变量 回到第一步","categories":[{"name":"SLAM","slug":"SLAM","permalink":"https://www.hpstu.cn/categories/SLAM/"}],"tags":[{"name":"g2o","slug":"g2o","permalink":"https://www.hpstu.cn/tags/g2o/"}]},{"title":"李群李代数","slug":"李群李代数","date":"2022-03-24T14:50:40.000Z","updated":"2022-05-01T13:18:19.181Z","comments":true,"path":"li-qun-li-dai-shu.html","link":"","permalink":"https://www.hpstu.cn/li-qun-li-dai-shu.html","excerpt":"","text":"李群李代数 ln(exp(ϕ^1)exp(ϕ^2))\\ln (\\exp (\\hat{\\phi}_1)\\exp(\\hat{\\phi}_2)) ln(exp(​ϕ​^​​​1​​)exp(​ϕ​^​​​2​​))","categories":[{"name":"SLAM","slug":"SLAM","permalink":"https://www.hpstu.cn/categories/SLAM/"}],"tags":[{"name":"李群李代数","slug":"李群李代数","permalink":"https://www.hpstu.cn/tags/%E6%9D%8E%E7%BE%A4%E6%9D%8E%E4%BB%A3%E6%95%B0/"}]},{"title":"","slug":"paper/笔记","date":"2022-03-24T14:47:08.821Z","updated":"2022-03-24T14:47:08.821Z","comments":true,"path":"paper/bi-ji.html","link":"","permalink":"https://www.hpstu.cn/paper/bi-ji.html","excerpt":"","text":"置顶快捷键 插入图片 Ctrl + Shift + I 插入链接 Ctrl + K 插入代码 Ctrl + Shift + K 插入公式 Ctrl + Shift + M 行内公式 $公式$ 加粗 Ctrl + B 下划线 Ctrl + U 字体倾斜 Ctrl + I 无序列表 + + Space 有序列表 1 + . + Space 降级列表 Tab 升级列表 Shift + Tab 创建表格 Ctrl + T RAFT RAFT: Recurrent All-Pairs Field Transforms for Optical Flow 2020 ECCV 创新: RAFT maintains and updates a single ﬁxed ﬂow ﬁeld at high resolution. This is diﬀerent from the prevailing coarse-to-ﬁne design in prior work [42,49,22,23,50], where ﬂow is ﬁrst estimated at low resolution and upsam- pled and reﬁned at high resolution. By operating on a single high-resolution ﬂow ﬁeld, RAFT overcomes several limitations of a coarse-to-ﬁne cascade: the diﬃ- culty of recovering from errors at coarse resolutions, the tendency to miss small fast-moving objects, and the many training iterations (often over 1M) typically required for training a multi-stage cascade RAFT以高分辨率维护和更新单个固定流场。这不同于之前工作[42,49,22,23,50]中普遍采用的从粗到细的设计，其中首先在低分辨率下估计流量，然后在高分辨率下进行上采样和重新定义。通过在单个高分辨率流场上运行，RAFT克服了粗到细级联的几个限制：难以从粗分辨率的错误中恢复，容易错过快速移动的小对象，以及训练多级级联通常需要的多次训练迭代（通常超过1M） LiteFlowNet3 2020 ECCV solve: 解决从粗到细的光流推断初始化错误问题","categories":[],"tags":[]},{"title":"VINSnote","slug":"VINSnote","date":"2022-03-24T12:48:35.000Z","updated":"2022-05-01T13:17:54.179Z","comments":true,"path":"vinsnote.html","link":"","permalink":"https://www.hpstu.cn/vinsnote.html","excerpt":"","text":"VINS笔记 编程实现四元数和李代数更新 可以使用四元数或旋转矩阵存储旋转变量。当我们用计算出来的 ω对某旋转更新时，有两种不同方式： R′←Rexp(ω^)\\bold{R^\\prime}\\leftarrow \\bold{R}\\,\\exp{({\\hat{\\omega}})} R​′​​←Rexp(​ω​^​​) OROR OR q′←q⨂[1,12ω]Tq\\prime\\leftarrow q\\bigotimes[1,\\frac{1}{2}\\omega]^T q′←q⨂[1,​2​​1​​ω]​T​​ 1234567891011121314151617181920212223int main()&#123; //初始化旋转矩阵 Eigen:: Matrix3d R=Eigen::AngleAxisd(M_PI/4,Eigen::Vector3d(0,0,1)).toRotationMatrix(); std::cout&lt;&lt;R.matrix()&lt;&lt;std::endl; Quaterniond q(R); Sophus::SO3d SO3_R(R); Sophus::SO3d SO3_q(q); std::cout&lt;&lt;&quot;SO(3) from matrix: &quot;&lt;&lt; SO3_R.matrix()&lt;&lt;std::endl; std::cout&lt;&lt;&quot;SO3 from quaternion&quot;&lt;&lt; SO3_q.matrix()&lt;&lt;std::endl; Vector3d update_w(0.01,0.02,0.03);//更新量 Sophus::SO3d SO3_updated = SO3_R * Sophus::SO3d::exp(update_w);//右乘更新 std::cout&lt;&lt;&quot;SO3_updated = &quot;&lt;&lt; endl &lt;&lt; SO3_updated.matrix()&lt;&lt;std::endl; Quaterniond update_q(1, update_w(0) / 2, update_w(1) / 2, update_w(2) / 2); //[1,1/2w] update_q.normalize();//归一化处理 Eigen::Quaterniond q_updated=q * update_q; //q_updated.normalize();//note:对更新量单独归一化或者更新完进行归一化都可以，结果一致 Sophus::SO3d SO3_q_updated(q_updated); std::cout&lt;&lt;&quot;SO3_q_updated = &quot;&lt;&lt; endl &lt;&lt; SO3_q_updated.matrix()&lt;&lt;std::endl; return 0;&#125;","categories":[{"name":"SLAM","slug":"SLAM","permalink":"https://www.hpstu.cn/categories/SLAM/"}],"tags":[{"name":"VINS","slug":"VINS","permalink":"https://www.hpstu.cn/tags/VINS/"}]},{"title":"C++ Tips","slug":"cTips","date":"2022-03-17T10:07:40.000Z","updated":"2022-05-01T13:11:38.304Z","comments":true,"path":"ctips.html","link":"","permalink":"https://www.hpstu.cn/ctips.html","excerpt":"","text":"文件操作 文件类型分为两种： 文本文件 - 文件以文本的ASCII码形式存储在计算机中 二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们 操作文件的三大类: ofstream：写操作 ifstream： 读操作 fstream ： 读写操作 ofstream ofs 默认打开方式是ios::out， ofs &lt;&lt; &quot;balabala&quot; ifstream ifs默认打开方式是ios:in ifs &gt;&gt; str &gt;&gt;,&lt;&lt; 箭头的朝向表示数据流到哪。一般文件流在前面。 文件打开方式： 打开方式 解释 ios::in 为读文件而打开文件 ios::out 为写文件而打开文件 ios::ate 初始位置：文件尾 ios::app 追加方式写文件 ios::trunc 如果文件存在先删除，再创建 ios::binary 二进制方式 文本文件 写文件步骤如下： 12345678910111213141516#include &lt;fstream&gt; // 包含头文件 int main()&#123; ofstream ofs; // 创建流对象 ofs.open((&quot;文件路径&quot;,打开方式) // 打开文件 （信息就保存在ofs这个流对象里了） ofs &lt;&lt; &quot;写入数据&quot;; ... ofs.close(); // 关闭文件，内容就刷新到文件里了 &#125;// 或者int main()&#123; ofstream ofs(&quot;文件路径&quot;,打开方式) // 调用构造方式。 ofs &lt;&lt; &quot;写入数据&quot;; ... ofs.close();&#125; 读文件步骤如下： 读文件与写文件步骤相似，但是读取方式相对于比较多 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;fstream&gt;#include &lt;string&gt;void test01()&#123; ifstream ifs; ifs.open(&quot;test.txt&quot;, ios::in); if (!ifs.is_open()) &#123; cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; return; &#125; //第一种方式 //char buf[1024] = &#123; 0 &#125;; //while (ifs &gt;&gt; buf) //&#123; // cout &lt;&lt; buf &lt;&lt; endl; //&#125; //第二种 //char buf[1024] = &#123; 0 &#125;; //while (ifs.getline(buf,sizeof(buf))) //&#123; // cout &lt;&lt; buf &lt;&lt; endl; //&#125; //第三种 //string buf; //while (getline(ifs, buf)) //&#123; // cout &lt;&lt; buf &lt;&lt; endl; //&#125; char c; while ((c = ifs.get()) != EOF) &#123; cout &lt;&lt; c; &#125; ifs.close();&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://www.hpstu.cn/categories/C/"}],"tags":[{"name":"C++文件操作","slug":"C-文件操作","permalink":"https://www.hpstu.cn/tags/C-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"}]},{"title":"C++模板","slug":"C模板","date":"2022-03-16T14:19:21.000Z","updated":"2022-05-01T13:12:51.809Z","comments":true,"path":"c-mo-ban.html","link":"","permalink":"https://www.hpstu.cn/c-mo-ban.html","excerpt":"","text":"C++ 模板 函数模板 模板函数与普通函数的区别： 函数模板不允许自动类型转换 ， 但传入实参时可以自动进行类型推导，不用加&lt;type &gt; 普通函数能够自动进行类型转换 同名函数优先调用普通函数，除非显式加&lt; type&gt; 类模板 调用时，类模板必须显示式指定类型 类模板派生普通类 12345678910111213141516171819template &lt;typename T&gt;class Person&#123;public: Person()&#123; mAge = 0; &#125;public: T mAge; &#125;// 1 派生类为普通类,需要指定类型 &lt;int&gt;class SubPerson1 : public Person&lt;int&gt;&#123; &#125;// 2 派生类为模板类template &lt;class T&gt;class SubPerson2 : public Person&lt;T&gt;&#123; &#125; 不要滥用友元 类模板.h文件·和.cpp文件分离编译在调用是会引发二次编译问题，所以一半将声明和实现都放在一个文件里，定义成.hpp文件。","categories":[{"name":"C++","slug":"C","permalink":"https://www.hpstu.cn/categories/C/"}],"tags":[{"name":"C++模板","slug":"C-模板","permalink":"https://www.hpstu.cn/tags/C-%E6%A8%A1%E6%9D%BF/"}]},{"title":"C++内置库以及函数","slug":"C内置库和函数","date":"2022-03-15T05:32:14.000Z","updated":"2022-05-01T13:07:05.906Z","comments":true,"path":"c-nei-zhi-ku-he-han-shu.html","link":"","permalink":"https://www.hpstu.cn/c-nei-zhi-ku-he-han-shu.html","excerpt":"","text":"C++内置库以及函数 sizeof 定义 sizeof是一个操作符（operator）。 其作用是返回一个对象或类型所占的内存字节数。 语法 sizeof有三种语法形式： 123&gt;1） sizeof (object); //sizeof (对象)&gt;2） sizeof object; //sizeof 对象3） sizeof (type_name); //sizeof (类型) 对象可以是各种类型的变量，以及表达式（一般sizeof不会对表达式进行计算）。 sizeof对对象求内存大小，最终都是转换为对对象的数据类型进行求值。 sizeof (表达式); //值为表达式的最终结果的数据类型的大小 基本数据类型的sizeof 这里的基本数据类型是指short、int、long、float、double这样的简单内置数据类型。 由于它们的内存大小是和系统相关的，所以在不同的系统下取值可能不同。 123456int i; sizeof(int); //值为4 sizeof(i); //值为4，等价于sizeof(int) sizeof i; //值为4 sizeof(2); //值为4，等价于sizeof(int)，因为2的类型为int sizeof(2 + 3.14); //值为8，等价于sizeof(double)，因为此表达式的结果的类型为double 结构体的sizeof 结构体的sizeof涉及到字节对齐问题。 为什么需要字节对齐？计算机组成原理教导我们这样有助于加快计算机的取数速度，否则就得多花指令周期了。为此，编译器默认会对结构体进行处理（实际上其它地方的数据变量也是如此），让宽度为2的基本数据类型（short等）都位于能被2整除的地址上，让宽度为4的基本数据类型（int等）都位于能被4整除的地址上，依次类推。这样，两个数中间就可能需要加入填充字节，所以整个结构体的sizeof值就增长了。 注意：空结构体（不含数据成员）的sizeof值为1。试想一个“不占空间“的变量如何被取地址、两个不同的“空结构体”变量又如何得以区分呢，于是，“空结构体”变量也得被存储，这样编译器也就只能为其分配一个字节的空间用于占位了。 1234567891011struct S1 &#123; char a; int b; &#125;; sizeof(S1); //值为8，字节对齐，在char之后会填充3个字节。 struct S2 &#123; &#125;; sizeof(S2); //值为1，空结构体也占内存 数组的sizeof 数组的sizeof值等于数组所占用的内存字节数。 注意：1）当字符数组表示字符串时，其sizeof值将’/0’计算进去。 ​ 2）当数组为形参时，其sizeof值相当于指针的sizeof值。 123456char a[10]; char n[] = &quot;abc&quot;; cout&lt;&lt;&quot;char a[10] &quot;&lt;&lt;sizeof(a)&lt;&lt;endl;//数组，值为10 cout&lt;&lt;&quot;char n[] = abc &quot;&lt;&lt;sizeof(n)&lt;&lt;endl;//字符串数组，将&#x27;/0&#x27;计算进去，值为4 指针的sizeof 指针是用来记录另一个对象的地址，所以指针的内存大小当然就等于计算机内部地址总线的宽度。 在32位计算机中，一个指针变量的返回值必定是4。 指针变量的sizeof值与指针所指的对象没有任何关系。 C++字符串 C++大大增强了对字符串的支持，除了可以使用C风格的字符串，还可以使用内置的 string 类。string 类处理起字符串来会方便很多，完全可以代替C语言中的字符数组或字符串指针 string 是 C++ 中常用的一个类 使用 string 类需要包含头文件&lt;string&gt;，下面的例子介绍了几种定义 string 变量（对象）的方法： 1234567891011#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string s1; string s2 = &quot;c plus plus&quot;; string s3 = s2; string s4 (5, &#x27;s&#x27;); return 0;&#125; 变量 s1 只是定义但没有初始化，编译器会将默认值赋给 s1，默认值是&quot;&quot;，也即空字符串。 变量 s2 在定义的同时被初始化为&quot;c plus plus&quot;。与C风格的字符串不同，string 的结尾没有结束标志'\\0'。 变量 s3 在定义的时候直接用 s2 进行初始化，因此 s3 的内容也是&quot;c plus plus&quot;。 变量 s4 被初始化为由 5 个's'字符组成的字符串，也就是&quot;sssss&quot;。 从上面的代码可以看出，string 变量可以直接通过赋值操作符=进行赋值。string 变量也可以用C风格的字符串进行赋值，例如，s2 是用一个字符串常量进行初始化的，而 s3 则是通过 s2 变量进行初始化的。 转换为C风格的字符串： 虽然 C++ 提供了 string 类来替代C语言中的字符串，但是在实际编程中，有时候必须要使用C风格的字符串（例如打开文件时的路径），为此，string 类为我们提供了一个转换函数 c_str()，该函数能够将 string 字符串转换为C风格的字符串，并返回该字符串的 const 指针（const char*）。 12string path = &quot;D:\\\\demo.txt&quot;;FILE* fp = fopen(path.c_str(), &quot;rt&quot;); // FILE是一个结构体，fopen参数为c风格字符串，该函数返回一个指向 FILE 结构的指针。 为了使用C语言中的 fopen() 函数打开文件，必须将 string 字符串转换为C风格的字符串。","categories":[{"name":"C++","slug":"C","permalink":"https://www.hpstu.cn/categories/C/"}],"tags":[{"name":"C++内置库","slug":"C-内置库","permalink":"https://www.hpstu.cn/tags/C-%E5%86%85%E7%BD%AE%E5%BA%93/"}]},{"title":"RANSAC","slug":"RANSAC","date":"2022-03-14T13:20:39.000Z","updated":"2022-05-01T13:08:27.009Z","comments":true,"path":"ransac.html","link":"","permalink":"https://www.hpstu.cn/ransac.html","excerpt":"","text":"算法流程 对于N个点构成的集合P，我们假定最少通过n个点可以拟合出正确的模型，也就是说样本集合中有N − n个噪声点。具体的执行下列操作： 从数据集中随机选择一组最小样本拟合模型H， 使用其他所有数据验证模型并从中取出符合阈值的内点， 如果内点数量达到阈值则保存该次所有内点，否则抛弃步骤2中的内点，执行步骤4， 重复以上步骤k次（即迭代k次）并更新内点（即保存步骤2中的最多内点）【可设置提前退出迭代机制，即内点足够多时退出（很难判断）】 然后使用最小二乘法重新拟合模型（步骤4中的所有内点） 参数说明 初始内点的确定 算法第1步中选择内点时，通常选择能确定模型的最少点，比如两点确定一条直线，3点确定一个平面。在求解单应性矩阵的时候，就是4个点对8个点确定一个矩阵模型。 迭代次数的确定 通常来说N的值比较大，那么随机选择点的时候，点与点的组合就很多，如果不对迭代次数进行限制，运算量就会很大。因为算法第2步要用剩余点对模型进行测试，如果点的数量较多，这一步的运算量很大。包括后面的第3，4步。其实我们只要保证我们估计模型的时候使用的都是内点即可。 假设是内点的概率为ppp: p=nini+nop= \\frac{n_i}{n_i + n_o} p=​n​i​​+n​o​​​​n​i​​​​ nin_in​i​​为内点数量,non_on​o​​ 为外点数量。那么我们每次计算模型使用nnn个点的情况下，选取的点集中至少有一个外点的概率就是：1−tn1 - t^n1−t​n​​那么在迭代kkk次的情况下，(1−tn)k(1-t^n)^k(1−t​n​​)​k​​就是次迭代都至少有1个外点的概率。 那么能够得到nnn个正确的点来估计模型的概率就是： P=1−(1−tn)tP=1 - (1 - t^n)^t P=1−(1−t​n​​)​t​​ 两边取对数，就可以得到最少迭代次数: k=log(1−P)log(1−tn)k = \\frac{\\log(1-P)}{\\log(1-t^n)} k=​log(1−t​n​​)​​log(1−P)​​ 这里PPP是希望通过算法得到正确模型的最少概率，kkk是关于PPP单调递增的,kkk就是在PPP确定情况下的最少迭代次数。ttt通常未知，那么我们可以采用自适应的办法，在开始的时候设置一个较大的迭代次数kkk，然后通过每次迭代中更新ttt来更新迭代次数。 代码示例 这里使用RANSAC算法来拟合直线:python代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import numpy as npimport matplotlib.pyplot as pltimport randomimport mathclass ransacMatchingTest(object): def __init__(self, X, Y, sigma=0.2, prob=0.95): self.X = X self.Y = Y self.sigma = sigma self.prob = prob def runMatch(self): preInlier = 0 iters = 10000 best_a = 0 best_b = 0 for i in range(iters): # sample points sampleIndex = random.sample(range(self.X.shape[0]), 2) x1 = self.X[sampleIndex[0]] y1 = self.Y[sampleIndex[0]] x2 = self.X[sampleIndex[1]] y2 = self.Y[sampleIndex[1]] # Compute mode a = (y2 - y1) / (x2 - x1) b = y1 - a * x1 # Get number of inlier inlier = 0 for index in range(self.X.shape[0]): y_estimate = a * self.X[index] + b if abs(y_estimate - self.Y[index]) &lt; self.sigma: inlier = inlier + 1 if inlier &gt; preInlier: # Update iteration times iters = math.log(1-self.prob) / math.log(1 - pow(inlier / self.X.shape[0], 2)) # 这句好像没起作用 preInlier = inlier best_a = a best_b = b # While inliers over half of input set then break if inlier &gt; (self.X.shape[0] / 2): break return best_a, best_bif __name__ == &#x27;__main__&#x27;: X = np.linspace(0, 10, 50) Y = 4 * X + 6 randomX = [] randomY = [] # Add mode noise for i in range(50): randomX.append(X[i] + random.uniform(-0.5, 0.5)) randomY.append(Y[i] + random.uniform(-0.5, 0.5)) # Add random noise for _ in range(50): randomX.append(random.uniform(0, 6)) randomY.append(random.uniform(6, 30)) RANDOMX = np.array(randomX) RANDOMY = np.array(randomY) ransac = ransacMatchingTest(RANDOMX, RANDOMY, sigma=0.2, prob=0.95).runMatch() preY = ransac[0] * RANDOMX + ransac[1] fig = plt.figure() ax1 = fig.add_subplot(1, 1, 1) ax1.scatter(RANDOMX, RANDOMY) ax1.plot(RANDOMX, preY) plt.show()","categories":[{"name":"SLAM","slug":"SLAM","permalink":"https://www.hpstu.cn/categories/SLAM/"}],"tags":[{"name":"RANSAC","slug":"RANSAC","permalink":"https://www.hpstu.cn/tags/RANSAC/"}]},{"title":"C++容器","slug":"C容器","date":"2022-03-14T11:08:32.000Z","updated":"2022-05-01T13:07:58.403Z","comments":true,"path":"c-rong-qi.html","link":"","permalink":"https://www.hpstu.cn/c-rong-qi.html","excerpt":"","text":"C++容器 vector vector是STL中最常见的容器，它是一种顺序容器，支持随机访问。vector是一块连续分配的内存，从数据安排的角度来讲，和数组极其相似，不同的地方就是：数组是静态分配空间，一旦分配了空间的大小，就不可再改变了；而vector是动态分配空间，随着元素的不断插入，它会按照自身的一套机制不断扩充自身的容量。 vector的扩充机制：按照容器现在容量的一倍进行增长。vector容器分配的是一块连续的内存空间，每次容器的增长，并不是在原有连续的内存空间后再进行简单的叠加，而是重新申请一块更大的新内存，并把现有容器中的元素逐个复制过去，然后销毁旧的内存。 vector数据结构，采用的是连续的线性空间，属于线性存储. vector对象的定义和初始化 操作调用方式 操作说明 Vector&lt;T&gt; v1; Vector保存类型为T的对象。默认构造函数v1为空 Vector&lt;T&gt; v2(v1); V2是v1的一个副本 Vector&lt;T&gt; v3(n , i); V3包含n个值为i的元素 Vector&lt;T&gt; v4(n); V4含有值初始化的元素的n个副本 注：对C++的容器来说，动态添加元素的效率，要比直接静态初始化元素的效率高 例1.1 :声明一个int向量以替代一维的数组:vector &lt;int&gt; a;(等于声明了一个int数组a[],大小没有指定,可以动态的向里面添加删除)。 例1.2: 用vector代替二维数组.其实只要声明一个一维数组向量即可,而一个数组的名字其实代表的是它的首地址,所以只要声明一个地址的向量即可,即:ector &lt;int *&gt; a. 对象的操作 操作调用方式 操作说明 v.empty() 判断v是否为空 v.size() 返回v中元素的个数 v.push_back(t) 向v的末尾添加一个元素 V[n] 返回v中位置为n的元素 V1 = v2 把v1中元素替换为v2中元素副本 V1==v2 判断是否相等 !=, &lt;, &lt;=, &gt;, &gt;= 直接用于vector对象的相互比较 1.push_back 在数组的最后添加一个数据 2.pop_back 去掉数组的最后一个数据 3.at 得到编号位置的数据 4.begin 得到数组头的指针 5.end 得到数组的最后一个单元+1的指针 6．front 得到数组头的引用 7.back 得到数组的最后一个单元的引用 8.max_size 得到vector最大可以是多大 9.capacity 当前vector分配的大小 10.size 当前使用数据的大小 11.resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值 12.reserve 改变当前vecotr所分配空间的大小 13.erase 删除指针指向的数据项 14.clear 清空当前的vector 15.rbegin 将vector反转后的开始指针返回(其实就是原来的end-1) 16.rend 将vector反转构的结束指针返回(其实就是原来的begin-1) 17.empty 判断vector是否为空 18.swap 与另一个vector交换数据 string","categories":[{"name":"C++","slug":"C","permalink":"https://www.hpstu.cn/categories/C/"}],"tags":[{"name":"容器","slug":"容器","permalink":"https://www.hpstu.cn/tags/%E5%AE%B9%E5%99%A8/"}]},{"title":"c++指针","slug":"c指针","date":"2022-03-14T08:20:25.000Z","updated":"2022-05-01T13:08:12.749Z","comments":true,"path":"c-zhi-zhen.html","link":"","permalink":"https://www.hpstu.cn/c-zhi-zhen.html","excerpt":"","text":"C++指针&amp;函数 复杂类型解析 一个类型里会出现很多运算符,他们也像普通的表达式一样,有优先级,其优先级和运算优先级一样, 解析原则:从变量名处起,根据运算符优先级结合,一步一步分析.（括号的优先级比*优先级高） 123456789int p; //这是一个普通的整型变量int *p; //首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针int p[3]; //首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组int *p[3]; //首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组int (*p)[3]; //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与&quot;()&quot;这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针int **p; //首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.int p(int); //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据Int (*p)(int); //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针int *(*p(int))[3]; //可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数. 1int *p[3]; 首先从变量p开始看起，p与[]结合，说明p是一个数组，那么就要问了，这个数据里放的数据是什么类型，欸，与最近的*结合，说明这个数组里的数据是指针，那么又要问了，这个指针指向什么类型，哦，原来指的是int类型，那么结果就出来了。 1int (*p)[3]; 同理: p是一个指针，这个指针指向一个数组，这个数组的类型是int型。 函数基本知识 C++对于返回值的类型有一定的限制：不能是数组，可以是其它任何类型–整数、浮点数、指针、结构和对象。（数组可以作为结构、对象组成部分来返回） 在C++中，当（且仅当）用于函数头或函数原型中，int * arr和int arr[ ] 的含义才相同，都意味着arr是一个int指针。","categories":[{"name":"C++","slug":"C","permalink":"https://www.hpstu.cn/categories/C/"}],"tags":[{"name":"指针","slug":"指针","permalink":"https://www.hpstu.cn/tags/%E6%8C%87%E9%92%88/"}]},{"title":"Markdown语法","slug":"Markdown语法","date":"2022-03-14T01:26:34.000Z","updated":"2022-05-01T13:16:32.185Z","comments":true,"path":"markdown-yu-fa.html","link":"","permalink":"https://www.hpstu.cn/markdown-yu-fa.html","excerpt":"","text":"Markdown格式 标题 使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。 123# 一级标题## 二级标题### 三级标题 显示效果： 一级标题 二级标题 三级标题 段落 编辑模式下可以在段落后面使用一个空行来表示重新开始一个段落。 123chapter1chapter2 字体 可以使用以下几种字体： 123456*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___ 显示效果： 斜体文本 斜体文本 粗体文本 粗体文本 粗斜体文本 粗斜体文本 分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。 123***---___ 显示效果： 删除线 如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可 1~~haha~~ 显示效果： haha 下划线 下划线可以通过 HTML 的 标签来实现： 1&lt;u&gt;带下划线文本&lt;/u&gt; 显示效果： 带下划线文本 列表 支持有序列表和无序列表。 无序列表使用星号()、加号(+)或是减号(-*)作为列表标记，这些标记后面要添加一个空格，然后再填写内容： 12345* 第一项+ 第一项- 第一项 有序列表使用数字并加上.号来表示 列表嵌套 列表嵌套只需在子列表中的选项前面添加四个空格即可： 区块 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号： 1&gt; 区块引用 显示结果： 区块引用 另外区块是可以嵌套的，一个&gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推： 123&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套 最外层 第一层嵌套 第二层嵌套 另外，在区块中可以保持其他语法的格式效果 代码 1使用 ``` 表示 或者 ` 表示 链接 12345[链接名称](链接地址)或者&lt;链接地址&gt; 这是一个链接 图片 开头一个感叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址（或者文件地址，最好使用相对地址），最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。 123![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;) 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 标签。 1&lt;img src=&quot;http://static.runoob.com/images/runoob-logo.png&quot; width=&quot;50%&quot;&gt; 表格 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 1234| 表头 | 表头 || ---- | ---- || 单元格 | 单元格 || 单元格 | 单元格 | 我们可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 1234| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 | 支持的 HTML 元素 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 使用 Ctrl+Alt+Del 重启电脑 转义 使用反斜杠转义特殊字符： 1\\ 公式 待更…","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://www.hpstu.cn/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://www.hpstu.cn/tags/Markdown/"}]},{"title":"Eigen","slug":"Eigen","date":"2022-03-13T12:03:14.000Z","updated":"2022-05-01T13:13:35.975Z","comments":true,"path":"eigen.html","link":"","permalink":"https://www.hpstu.cn/eigen.html","excerpt":"","text":"Eigen 1234567a = a.transpose(); // !!! do NOT do this !!!// For in-place transposition, as for instance in a = a.transpose(), simply use the transposeInPlace() function:a.transposeInPlace();// Eigen treats matrix multiplication as a special case and takes care of introducing a temporary here, so it will compile m=m*m as:// tmp = m*m;// m = tmp; 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;Eigen/Dense&gt; using namespace std;int main()&#123; Eigen::Matrix2d mat; mat &lt;&lt; 1, 2, 3, 4; cout &lt;&lt; &quot;Here is mat.sum(): &quot; &lt;&lt; mat.sum() &lt;&lt; endl; cout &lt;&lt; &quot;Here is mat.prod(): &quot; &lt;&lt; mat.prod() &lt;&lt; endl; cout &lt;&lt; &quot;Here is mat.mean(): &quot; &lt;&lt; mat.mean() &lt;&lt; endl; cout &lt;&lt; &quot;Here is mat.minCoeff(): &quot; &lt;&lt; mat.minCoeff() &lt;&lt; endl; cout &lt;&lt; &quot;Here is mat.maxCoeff(): &quot; &lt;&lt; mat.maxCoeff() &lt;&lt; endl; cout &lt;&lt; &quot;Here is mat.trace(): &quot; &lt;&lt; mat.trace() &lt;&lt; endl;&#125;/*Here is mat.sum(): 10Here is mat.prod(): 24Here is mat.mean(): 2.5Here is mat.minCoeff(): 1Here is mat.maxCoeff(): 4Here is mat.trace(): 5*/","categories":[{"name":"SLAM","slug":"SLAM","permalink":"https://www.hpstu.cn/categories/SLAM/"}],"tags":[{"name":"Eigen","slug":"Eigen","permalink":"https://www.hpstu.cn/tags/Eigen/"}]},{"title":"c++多线程","slug":"c多线程","date":"2022-03-12T07:17:55.000Z","updated":"2022-05-01T13:12:01.568Z","comments":true,"path":"c-duo-xian-cheng.html","link":"","permalink":"https://www.hpstu.cn/c-duo-xian-cheng.html","excerpt":"","text":"C++多线程 引入头文件： 1#include &lt;thread&gt; 链接库： 1target_link_libraries(xxx pthread) 线程 • 进程可以包含多个线程 • 主线程：从main函数开始，main函数执行完，主线程结束，进程结束 • 其他线程：需要我们自己创建，入口可以是函数、类、lambda表达式 • 进程是否执行完毕的标志是：主线程是否执行完，如果主线程执行完毕了，就代表整个进程执行完 了，一般来说，此时如果其他子线程还没有执行完，也会被强行终止 创建子线程 1std::thread // 多线程类 123456int main()&#123; thrad th1(xx); // 使用其创建子线程对象的时候，子线程就直接运行了。 ... th1.join(); // 汇合，表示等待子线程运行完，主线程再接着运行。（小溪汇入大河）&#125; 123456789int main()&#123; thrad th2(xx); // 使用其创建子线程对象的时候，子线程就直接运行了。 ... th2.detach(); // 分离，表示子线程脱离子线程，各走各的，互不相关（分流了），注意，此时如果主线程运行完毕，则直接关闭所有线程，子线程没运行完也停止运行。（夭折了），少用。 th2.joinable() // joinable()判断是否可以成功使用join()或者detach(),如果返回true，证明可以调用join()或者detach(),如果返回false，证明调用过join()或者detach()，join()和detach()都不能再调用了&#125; 查看线程ID: 1this_thread::get_id() // this_thread是一个namespace, 进程间安全（防止读写冲突，就给它上锁） 1#include &lt;mutex&gt; // 互斥锁头文件 ，mutex也是一个对象，相当于一把锁。 使用方法： 先创建一个锁对象： 1mutex myMutex; 上锁是防止多个线程同时对同一个数据快进行读写，造成冲突，（也就是前一个线程刚写入一半数据，你就过来读了），正确姿势是等他写完你再读，或读完你再写。所以，当其中一个线程拿到一把锁时： 12345// 线程1myMutex.lock(); cout &lt;&lt; &quot;putInData 子线程：放入一个数据&quot; &lt;&lt; i &lt;&lt; endl;dataQuene.push_back(i);myMutex.unlock(); 12345// 线程2myMutex.lock(); cout &lt;&lt; &quot;takeOutData 子线程：取出一个数据&quot; &lt;&lt; dataQuene.front() &lt;&lt; endl;dataQuene.pop_front();myMutex.unlock(); 这两个线程为互斥关系，各自当执行到myMutex.lock()时，必须等一个拿到锁的代码快完整执行到释放锁myMutex.unlock()了，另一个才可能拿到锁继续执行。 注意：lock()与unlock()必须成对出现，锁定后不解锁，或者重复解锁都会出问题 lock_guard 内部构造时相当于执行了lock，析构时相当于执行unlock 简单但不如lock()和unlock()灵活，通过大括号来实现，控制生命周期 1234567mutex myMutex;&#123; lock_guard&lt;mutex&gt; dataGuard(myMutex); // lock_guard&lt;mutex&gt;创建对象，参数为锁对象 ... ... &#125; unique_lock std::unique_lock要比std::lock_guard功能更多，有更多的成员函数，更灵活,但是更灵活的代价是占用空间相对更大一点且相对更慢一点 1234567mutex myMutex;&#123; unique_lock&lt;mutex&gt; dataOutUnique(myMutex); // unique_lock&lt;mutex&gt;创建对象，参数为锁对象 ... ... &#125; 死锁产生原因及防止方法 当两个线程同时拿着两把及以上的相同的锁时，上锁的顺序必须要一致，否则会发生死锁。","categories":[{"name":"C++","slug":"C","permalink":"https://www.hpstu.cn/categories/C/"}],"tags":[{"name":"C++多线程","slug":"C-多线程","permalink":"https://www.hpstu.cn/tags/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"C++面向对象","slug":"C面向对象","date":"2022-03-11T02:39:35.000Z","updated":"2022-05-01T13:12:39.312Z","comments":true,"path":"c-mian-xiang-dui-xiang.html","link":"","permalink":"https://www.hpstu.cn/c-mian-xiang-dui-xiang.html","excerpt":"","text":"Object Oriented Header(头文件)布局 12345678910111213141516171819#ifndef __COMPLEX__#define __COMPLEX__#include &lt;cmath&gt;class ostream; // forward declarationsclass complex; // 前置声明complex&amp;__doapl (complex* ths, const complex&amp; r);class complex // class declarations&#123; // 类-声明...&#125;;complex::function ... // class definition // 类-定义#endif 构造函数 构造函数不能带返回值，函数名必须与类名一致，可以列表初始化： 12345678910111213141516171819class complex&#123;public:complex (double r = 0, double i = 0): re (r), im (i) // initialization list&#123; &#125; // assignments 赋值 complex (double r = 0, double i = 0)&#123; re = r; im = i; &#125;complex&amp; operator += (const complex&amp;);double real () const &#123; return re; &#125;double imag () const &#123; return im; &#125;private:double re, im;friend complex&amp; __doapl (complex*, const complex&amp;); &#125;; 12345678// 以下两种创建对象方式没有区别complex c1complex c2()// 因此，不能出现以下方式的两种构造函数，会发生歧义 complex (double r = 0, double i = 0): re (r), im (i) &#123; &#125;complex () : re(0), im(0) &#123; &#125; const 12345double real () const &#123; return re; &#125;// const 放在这个位置表示他不会改变&#123;&#125;中引进来的数据，也就是不会改变对象中的数据re.(如果你真的不会改变对象中的数据，那你最好一定要加const,防止外部调用时出错)// eg. 如果real()声明时没加const，下面就会报错const complex c1(1,3);cout &lt;&lt; c1.real(); pass by reference &amp; return by reference 传递参数尽量都传递引用，如果不想改变该参数，就加const修饰。 返回值也尽量传递引用（如果可以的话）。 参数传递和返回其实相当于赋值（也即复制），以什么方式递出去，以什么方式接收是各自的事情。 return xx 和实参相当于是传递者，返回值 和形参相当于是接收者即赋值操作：（ 接收 = 传递） 函数的返回值用于初始化在调用函数时创建的临时对象(temporary object)，如果返回类型不是引用，在调用函数的地方会将函数返回值复制给临时对象。 当函数返回非引用类型时，其返回值既可以是局部对象 千万不要返回局部对象的引用！千万不要返回指向局部对象的指针！ 123456int&amp; abc(int a, int&amp; result) // result接收的是该参数的引用。&#123; result = a; return result; // 返回的是值，单以引用方式接收&#125; 操作符重载（操作符也相当于是函数） 所有的成员函数隐藏了一个this参数（即对象的地址指针），在声明函数的时候不能显式声明，但可以显式调用 Object Based Big Three 三个特殊函数（class with pointer members 必须有copy ctor 和 copy op ) 1234567891011class String&#123;public:String(const char* cstr = 0); String(const String&amp; str); // 1. 拷贝构造函数，参数为相同对象String&amp; operator=(const String&amp; str); // 2. 拷贝赋值函数，参数为相同对象~String(); // 3. 析构函数，当对象死亡时自动调用它，并不是它让对象死亡char* get_c_str() const &#123; return m_data; &#125;private:char* m_data;&#125;; 123456Complex* pc = new Complex(1,2);...delete pc;// 编译器转化为：//Complex::~Complex(pc); // 析构函数//operator delete(pc); // 释放内存，其内部调用 free(pc)","categories":[{"name":"C++","slug":"C","permalink":"https://www.hpstu.cn/categories/C/"}],"tags":[{"name":"C++面向对象","slug":"C-面向对象","permalink":"https://www.hpstu.cn/tags/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"C++关键字","slug":"C关键字","date":"2022-03-11T01:59:07.000Z","updated":"2022-05-01T13:19:43.242Z","comments":true,"path":"c-guan-jian-zi.html","link":"","permalink":"https://www.hpstu.cn/c-guan-jian-zi.html","excerpt":"","text":"inline 定义内联函数，该关键字是基于定义的。如果只在函数声明时给出inline，则函数不会被认为是内联函数，所以必须在函数定义的地方也加上inline。 const 定义常量成员，包括const数据成员和const成员函数，const数据成员必须也只能通过构造函数的初始化列表进行初始化。 const成员函数只能访问类的成员，不能进行修改，如果需要修改，则引入mutable关键字。 const修饰普通变量（两种写法都类似）： 12const TYPE value; TYPE const value; const修饰指针 指针本身是常量不可变：(char*) const pContent; 指针所指向的内容是常量不可变：const (char) *pContent;或(char) const *pContent; 两者都不可变：const char* const pContent; const修饰函数 const修饰函数参数是它最广泛的一种用途，它表示在函数体中不能修改参数的值(包括参数本身的值或者参数其中包含的值) const修饰类对象/对象指针/对象引用 const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。 const修饰数据成员 const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类声明中初始化const数据成员，因为类的对象未被创建时，编译器不知道const 数据成员的值是什么。 const修饰成员函数 const修饰类的成员函数，用const修饰的成员函数不能改变对象的成员变量。一般把const写在成员函数的最后。 static 声明静态成员，包括静态数据成员和静态成员函数，它们被类的所有对象共享，静态数据成员在使用前必须初始化，而静态成员函数只能访问静态数据成员，不能访问非静态数据成员，因为该函数不含有this指针。、 写在class内的东西都是声明而不是定义，因此对于静态成员需要在类外面给出其定义。静态成员在初始化时不能加static关键字，因为加了static关键字表明该变量只在当前文件内访问，而类设计时类中的成员变量是可能在其他文件中被访问的，两者相悖，因此这里不能加static关键字。 当静态成员为public时对其的访问可用对象名加.符号进行访问，也可以用类名加：：作用域解析运算符进行访问。 面向过程的static关键字 （1）静态全局变量： 全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。 1、该变量在全局数据区分配内存； 2、未经初始化的静态全局变量会被程序自动初始化为0； 3、静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的。其它文件中可以定义相同名字的变量，不会发生冲突。定义全局变量就可以实现变量在文件中的共享。 （2）静态局部变量： 在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。 静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次函数调用，直到下次赋新值。 静态局部变量有以下特点： 1、该变量在全局数据区分配内存； 2、静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化(跳过 static int a = 4;这一句，后面的赋值a = 5照常执行)； 3、静态局部变量一般在声明处初始化，如果没有显式初始化，程序自动初始化为0； 4、它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束 （3）静态函数： 在函数的返回类型前加上static关键字，函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。其它文件中可以定义相同名字的函数，不会发生冲突。 面向对象的static关键字 （1）静态数据成员 在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。 对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。静态函数可以访问类的静态成员变量，且只能访问静态成员变量。调用时可以使用对象名加.符号进行调用，也可以使用类名加：：作用于解析运算符进行调用。因此静态函数中不能使用this指针访问静态成员，因为当使用：：进行调用静态函数时，此时没有传入this指针，所以它访问的数据都不是自己的，而是类共有的，这个数据只能是类成员变量，即静态数据了。 1、对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。 2、静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。 3、静态数据成员和普通数据成员一样遵从public,protected,private访问规则。 4、静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象。 5、在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它； 6、静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为： ＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞（前面不加static,否则就被锁定只能在这个文件使用了，这不是类想要的结果） 7、类的静态数据成员有两种访问形式：＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞ 8、静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性。 （2）静态成员函数 与静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。静态成员函数与静态数据成员一样，都是类的内部实现，属于类定义的一部分。 普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。下面举个静态成员函数的例子。 关于静态成员函数，可以总结为以下几点： 1、出现在类体外的函数定义不能指定关键字static； 2、静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数； 3、非静态成员函数可以任意地访问静态成员函数和静态数据成员； 4、静态成员函数不能访问非静态成员函数和非静态数据成员； 5、由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长； 6、调用静态成员函数，可以用成员访问操作符来调用静态成员函数，也可以直接使用如下格式： ＜类名＞::＜静态成员函数名＞（＜参数表＞） virtual 声明虚函数，用于实现多态，该关键字是基于声明的。 所谓虚函数，虚就虚在“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。 由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被称为“虚”函数。只要在基类中已声明为virtual，这里即使不使用virtual关键字，默认也是虚函数。同样，如果还有从子类派生的子类，对应的成员函数也是虚函数。 虚函数 虚函数只能借助于指针或者引用来达到多态的效果 通过这些手段，编译器在看到一个虚函数调用的时候，就将会在运行时刻决定调用哪个函数。虚函数必须要被定义。 虚析构函数 析构函数也可以是虚的，甚至是纯虚的。当一个类打算被用作其它类的基类时，它的析构函数必须是虚的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生。而直接用继承类的指针去操作继承类的成员，却不会出现这种情况。 纯虚函数 如下声明表示一个函数为纯虚函数（纯虚函数也可以有定义）（如果一个类里面有一个或多个纯虚函数，这个类就是抽象类）。纯虚函数用来规范派生类的行为，实际上就是所谓的“接口”。它告诉使用者，我的派生类都会有这个函数。而试图创建一个抽象基类的独立类对象会导致编译时刻错误。 virtual void foo()=0; // =0标志一个虚函数为纯虚函数 构造函数和析构函数中的虚函数调用 一个类的虚函数在它自己的构造函数和析构函数中被调用的时候，它们就变成普通函数了。也就是说不能在构造函数和析构函数中让自己“多态”。这是因为派生类对象中构造函数的调用顺序是，先调用基类的构造函数，然后是派生类的构造函数。在基类析构函数中也是如此。 虚函数与纯虚函数的区别 虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。 虚函数可以被直接使用（必须被定义），也可以被子类重载以后以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类只有声明而没有定义。 虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。 虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。 定义了纯虚函数的类称为抽象类，抽象类不能被实例化。 friend 声明友元函数和友元类，该关键字也是基于声明的。 采用类的机制后实现了数据的隐藏与封装，类的数据成员一般定义为私有成员，成员函数一般定义为公有的，依此提供类与外界间的通信接口。 友元函数 有时需要定义一些函数，这些函数不是类的一部分（注意友元函数不是类的一部分），但又需要频繁地访问类的数据成员，这时可以将这些函数定义为该类的友元函数。 友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend，其格式如下： friend 类型 函数名(形式参数); 友元函数的声明可以放在类的私有部分，也可以放在公有部分，它们是没有区别的，都说明是该类的一个友元函数。 一个函数可以是多个类的友元函数，只需要在各个类中分别声明。友元函数的调用与一般函数的调用方式和原理一致。 友元函数并不是类的成员函数，因此在类外定义的时候不能加上class::function name 2.友元类 除了友元函数外，还有友元类，两者统称为友元。友元的作用是提高了程序的运行效率（即减少了类型检查和安全性检查等都需要时间开销），但它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。同友元函数一样，其也需要在类中加上关键字friend声明。 友元类的所有成员函数都是类的友元函数，能存取类的私有成员和保护成员。 友元关系不能被继承。 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明。 *_cast 显式类型转换，C延续了C风格的强制类型转换的语法。dynamic_cast是动态的，需要运行时支持；其它都是静态检查，相比C风格的类型转换更加细化，增强了类型安全性。C支持四种关键字对不同形式的类型转换进行分别处理。使用格式： 转换关键字&lt;类型&gt;(表达式) 1、static_cast和C风格类型转换功能完全相同，它属于在编译时期静态的类型转换。如果把一个double类型转换为整形，形式如下： static_cast&lt;int&gt;(0.1); static_cast功能有所限制，比如不能转化struct类型到int，不能转化指针到double等。另外，它不能在转换中消除const和volatile属性。 运算符 static_cast 可用于将指向基类的指针转换为指向派生类的指针等操作。 此类转换并非始终安全。 在下面的示例中，因为 D* pd2 = static_cast&lt;D*&gt;(pb); 可能有不在 D 内的字段和方法，所以行 B 不安全。 但是，因为 B* pb2 = static_cast&lt;B*&gt;(pd); 始终包含所有 D，所以行 B 是安全的转换。 12345678910111213// static_cast_Operator.cpp// compile with: /LDclass B &#123;&#125;;class D : public B &#123;&#125;;void f(B* pb, D* pd) &#123; D* pd2 = static_cast&lt;D*&gt;(pb); // Not safe, D can have fields // and methods that are not in B. B* pb2 = static_cast&lt;B*&gt;(pd); // Safe conversion, D always // contains all of B.&#125; 与 dynamic_cast相反，不会对 的转换进行运行时 检查 pb。 由 pb 指向的对象可能不是 D 类型的对象，在这种情况下使用 *pd2 会是灾难性的。 例如，调用 D 类（而非 B 类）的成员函数可能会导致访问冲突 2、const_cast用于消除引用或者指针的const或者volatile属性。 const int &amp;ci=100; int &amp;i=const_cast&lt;int&amp;&gt;(ci); 通过这种方式，ci引用的内存单元虽然无法通过修改ci改变，但是可以修改i改变内存的值。这里是把const属性消除，这里想多说一点的是把const加上的问题。 3、dynamic_cast一般出现在类到子类或兄弟类的转换，并要求基类有虚函数。而且它能提供转换后的结果和状态，一旦转换失败则返回空指针。如果没有继承关系的转换一般使用static_cast。 4、reinterpret_casts一般用作函数指针的转换，而且使用它的代码可移植性很差，因为无法确定编译器的函数调用方式等。有可能会导致函数调用出错，一般不常用。 explicit explicit关键字只能用于修饰只有一个参数的类构造函数，它的作用是表明该构造函数是显示的，而非隐式的，跟它相对应的另一个关键字是implicit，意思是隐藏的，类构造函数默认情况下即声明为implicit(隐式)。 explicit关键字只对有一个参数的类构造函数有效，如果类构造函数参数大于或等于两个时，是不会产生隐式转换的，所以explicit关键字也就无效了，而除了第一个参数以外的其他参数都有默认值的时候，explicit关键字依然有效。 除非有心利用，隐式转换常常带来程序逻辑的错误，而且这种错误一旦发生是很难察觉的。原则上应该在所有的构造函数前加explicit关键字，当你有心利用隐式转换的时候再去解除explicit，这样可以大大减少错误的发生。 隐式转换的含义：在C++中，如果的构造函数只有一个参数时，那么在编译的时候就会有一个缺省的转换操作：将该构造函数对应数据类型的数据转换为该类对象。也就是说CxString string2 = 10;这段代码，编译器自动将整型转换为CxString类对象，实际上等同于CxString string2(10); extern extern意为“外来的”，是存储类声明修饰符。其有两个作用： 当它与”C”一起连用时，如: extern &quot;C&quot; void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C的，C的规则在翻译这个函数名时会把fun这个名字变得面目全非，可能是fun@aBc_int_int#%$也可能是别的，这要看编译器的”脾气”了(不同的编译器采用的方法不一样)，主要是因为C++支持函数的重载。 当extern不与”C”在一起修饰变量或函数时，如在头文件中: extern int g_Int;它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块引用其他模块中的定义，记住它是一个声明不是定义，仅仅是暗示这个函数可能在别的源文件里定义，没有其它作用。这样的用处还是有的，就是在程序中取代include “*.h”来声明函数，在一些复杂的项目中，我比较习惯在所有的函数声明前添加extern修饰。 1、extern 和 static （1）extern 表明该变量在别的地方已经定义过了，在这里要使用那个变量。 （2）static 表示静态的变量，分配内存的时候，存储在静态区，不存储在栈上面。 static 作用范围是内部连接的关系, 和extern有点相反。static与extern是一对“水火不容”的家伙，也就是说extern和static不能同时修饰一个变量。 2、extern 和const C++中const修饰的全局常量据有跟static相同的特性，即它们只能作用于本编译模块中，但是const可以与extern连用来声明该常量可以作用于其他编译模块中, 如extern const char g_str[];","categories":[{"name":"C++","slug":"C","permalink":"https://www.hpstu.cn/categories/C/"}],"tags":[{"name":"C++关键字","slug":"C-关键字","permalink":"https://www.hpstu.cn/tags/C-%E5%85%B3%E9%94%AE%E5%AD%97/"}]},{"title":"git","slug":"git2","date":"2022-03-10T13:40:07.000Z","updated":"2022-05-01T13:14:59.743Z","comments":true,"path":"git2.html","link":"","permalink":"https://www.hpstu.cn/git2.html","excerpt":"","text":"安装好Git后必须要设置的一步（设置用户名和邮箱）： 12345git config --global user.name hpstu # --global为可选项git config --global user.email 571091694@qq.com#查看配置git config --global --list # --global可选git config --system --list 创建项目 1234#在当前目录新建一个Git代码库git init# orgit clone [url] 查看文件状态 12345678# 查看指定文件状态git status [filename]# 查看所有文件状态git status# 添加所有文件到暂存区git add .# 提交暂存区的内容到本地仓库，-m后面可以跟提交信息git commit -m &quot;提交的信息&quot; 文件.gitignore 有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等。 在主目录下建立”.gitignore”文件，此文件有如下规则： # 表示注释 可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1，string2.…}）代表可选的字符串等。 如果名称的最前面有一个感叹号（！），表示例外规则，将不被忽略。 如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。 如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。 git分支 123456789101112131415# 列出所有本地分支git branch# 列出所有远程分支git branch -r# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch-name]# 合并指定分支到当前分支git merge [branch-name]# 删除分支git branch -d [branch-name]# 删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch]","categories":[{"name":"git","slug":"git","permalink":"https://www.hpstu.cn/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.hpstu.cn/tags/git/"}]},{"title":"git","slug":"git","date":"2022-03-06T04:27:04.000Z","updated":"2022-03-24T14:47:08.520Z","comments":true,"path":"git.html","link":"","permalink":"https://www.hpstu.cn/git.html","excerpt":"","text":"Git 和 GitHub 详解 （一）Git 基础 Git 下载和安装 下载地址： https://git-scm.com/downloads 使用默认值安装 资源管理器内单击鼠标右键选择 Git Bash Here 输入git --version 检查是否安装成功 Git 基本工作流程 主要涉及到四个关键点： 工作区：本地电脑存放项目文件的地方，比如 learnGitProject 文件夹； 暂存区（Index/Stage）：在使用 git 管理项目文件的时候，其本地的项目文件会多出一个.git 的文件夹，将这个.git 文件夹称之为版本库。其中.git 文件夹中包含了两个部分，一个是暂存区（Index 或者 Stage）,顾名思义就是暂时存放文件的地方，通常使用 add 命令将工作区的文件添加到暂存区里； 本地仓库：.git 文件夹里还包括 git 自动创建的 master 分支，并且将 HEAD 指针指向 master 分支。使用 commit 命令可以将暂存区中的文件添加到本地仓库中； 远程仓库：不是在本地仓库中，项目代码在远程 git 服务器上，比如项目放在 github 上，就是一个远程仓库，通常使用 clone 命令将远程仓库拷贝到本地仓库中，开发后推送到远程仓库中即可； 因此，经过这样的分析，git 命令可以分为这样的逻辑进行理解和记忆： git 管理配置的命令； 几个核心存储区的交互命令： 工作区与暂存区的交互； 暂存区与本地仓库（分支）上的交互； 本地仓库与远程仓库的交互。 作者：你听___ 链接：https://juejin.im/post/5ae072906fb9a07a9e4ce596 来源：掘金 工作目录 暂存区 git 仓库 远程仓库 被 Git 管理的项目 临时存放被修改的文件 目录用于存放提交记录 远程代码仓库 git init git add git commit git push Git 使用前的配置命令 在使用前告诉 git 你是谁： 第一次使用 git，配置用户信息 配置用户名：git config --global user.name &quot;your name&quot;; 配置用户邮箱：git config --global user.email &quot;youremail@github.com&quot;; 查询配置信息 列出当前配置：git config --list; 列出 repository 配置：git config --local --list; 列出全局配置：git config --global --list; 列出系统配置：git config --system --list; 其他配置 配置解决冲突时使用哪种差异分析工具，比如要使用 vimdiff：git config --global merge.tool vimdiff; 配置 git 命令输出为彩色的：git config --global color.ui auto; 配置 git 使用的文本编辑器：git config --global core.editor vi; 注： 更改–&gt;重复上述命令 也可直接修改 C:\\Users\\用户\\.gitconfig 工作区上的操作命令 提交步骤 git init 初始化 git 仓库 新建仓库 将工作区中的项目文件使用 git 进行管理，即创建一个新的本地仓库：git init； 从远程 git 仓库复制项目：git clone; 克隆项目时如果想定义新的项目名，可以在 clone 命令后指定新的项目名：git clone git://github.com/wasd/example.git NewName； git status 查看文件状态 查新信息 查询当前工作区所有文件的状态：git status; 比较工作区中当前文件和暂存区之间的差异，也就是修改之后还没有暂存的内容：git diff；指定文件在工作区和暂存区上差异比较：git diff; git add 文件/文件列表 提交到暂存区 提交 提交工作区所有文件到暂存区：git add . 提交工作区中指定文件到暂存区：git add ...; 提交工作区中某个文件夹中所有文件到暂存区：git add [dir]; git commit -m 提交信息 向仓库提交代码 提交文件到版本库 将暂存区中的文件提交到本地仓库中，即打上新版本：git commit -m &quot;commit_info&quot;; 将所有已经使用 git 管理过的文件暂存后一并提交，跳过 add 到暂存区的过程：git commit -a -m &quot;commit_info&quot;; 提交文件时，发现漏掉几个文件，或者注释写错了，可以撤销上一次提交：git commit --amend; git log 查看提交记录 查看信息 比较暂存区与上一版本的差异：git diff --cached; 指定文件在暂存区和本地仓库的不同：git diff --cached; 查看提交历史：git log；参数-p展开每次提交的内容差异，用-2显示最近的两次更新，如git log -p -2; 撤销 用暂存区中的文件覆盖工作目录中的文件：git checkout -- 文件名 不加 -- 文件名则覆盖全部文件 将文件从暂存区中删除：git rm --cached 文件名 将 git 仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录：git reset --hard commitID 撤销 删除工作区文件，并且也从暂存区删除对应文件的记录：git rm; 从暂存区中删除文件，但是工作区依然还有该文件:git rm --cached; 取消暂存区已经暂存的文件：git reset HEAD ...; 撤销上一次对文件的操作：git checkout --。要确定上一次对文件的修改不再需要，如果想保留上一次的修改以备以后继续工作，可以使用 stashing 和分支来处理； 隐藏当前变更，以便能够切换分支：git stash； 查看当前所有的储藏：git stash list； 应用最新的储藏：git stash apply，如果想应用更早的储藏：git stash apply stash@&#123;2&#125;；重新应用被暂存的变更，需要加上--index参数：git stash apply --index; 使用 apply 命令只是应用储藏，而内容仍然还在栈上，需要移除指定的储藏：git stash drop stash&#123;0&#125;；如果使用 pop 命令不仅可以重新应用储藏，还可以立刻从堆栈中清除：git stash pop; 在某些情况下，你可能想应用储藏的修改，在进行了一些其他的修改后，又要取消之前所应用储藏的修改。Git 没有提供类似于 stash unapply 的命令，但是可以通过取消该储藏的补丁达到同样的效果：git stash show -p stash@&#123;0&#125; | git apply -R；同样的，如果你沒有指定具体的某个储藏，Git 会选择最近的储藏：git stash show -p | git apply -R； 更新文件 重命名文件，并将已改名文件提交到暂存区：git mv [file-original] [file-renamed]; （二）Git 进阶 分支 生成副本，避免影响开发主线 分支细分 主分支（master）：第一次向 git 仓库提交更新记录时自动产生的一个分支。 开发分支（develop）：作为开发的分支，基于 master 分支创建。 功能分支（feature）：作为开发具体功能的分支基于开发分支创建。 分支命令 git branch 查看分支 git branch 分支名称 创建分支 git checkout 分支名称 切换分支 git merge 来源分支 合并分支 git branch -d 分支名称 删除分支（分支合并后才允许被删除）（-D 大写强制删除） git push origin :branch-name : 远程仓库同步删除掉的分支 注意： 开发分支文件后要 commit 后再切换主分支，否则分支文件会出现在主分支里面。 分支管理 创建分支：git branch，如git branch testing； 从当前所处的分支切换到其他分支：git checkout，如git checkout testing； 新建并切换到新建分支上：git checkout -b; 删除分支：git branch -d； 将当前分支与指定分支进行合并：git merge; 显示本地仓库的所有分支：git branch; 查看各个分支最后一个提交对象的信息：git branch -v; 查看哪些分支已经合并到当前分支：git branch --merged; 查看当前哪些分支还没有合并到当前分支：git branch --no-merged; 把远程分支合并到当前分支：git merge /，如git merge origin/serverfix；如果是单线的历史分支不存在任何需要解决的分歧，只是简单的将 HEAD 指针前移，所以这种合并过程可以称为快进（Fast forward），而如果是历史分支是分叉的，会以当前分叉的两个分支作为两个祖先，创建新的提交对象；如果在合并分支时，遇到合并冲突需要人工解决后，再才能提交； 在远程分支的基础上创建新的本地分支：git checkout -b /，如git checkout -b serverfix origin/serverfix; 从远程分支 checkout 出来的本地分支，称之为跟踪分支。在跟踪分支上向远程分支上推送内容：git push。该命令会自动判断应该向远程仓库中的哪个分支推送数据；在跟踪分支上合并远程分支：git pull； 将一个分支里提交的改变移到基底分支上重放一遍：git rebase，如git rebase master server，将特性分支 server 提交的改变在基底分支 master 上重演一遍；使用 rebase 操作最大的好处是像在单个分支上操作的，提交的修改历史也是一根线；如果想把基于一个特性分支上的另一个特性分支变基到其他分支上，可以使用--onto操作：git rebase --onto，如git rebase --onto master server client；使用 rebase 操作应该遵循的原则是：一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行 rebase 操作； 暂时保存更改 git 中可以不提交更改，只提取分支上所有改动并储存，让开发人员得到一个干净的副本，临时转向其它工作。复制到“剪切板”，可以“粘贴“到其它分支。 场景： 储存临时改动：git stash 恢复临时改动：git stash pop 打标签 Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。 列出现在所有的标签：git tag; 使用特定的搜索模式列出符合条件的标签，例如只对 1.4.2 系列的版本感兴趣：git tag -l &quot;v1.4.2.*&quot;; 创建一个含附注类型的标签，需要加-a参数，如git tag -a v1.4 -m &quot;my version 1.4&quot;; 使用 git show 命令查看相应标签的版本信息，并连同显示打标签时的提交对象：git show v1.4; 如果有自己的私钥，可以使用 GPG 来签署标签，只需要在命令中使用-s参数：git tag -s v1.5 -m &quot;my signed 1.5 tag&quot;; 验证已签署的标签：git tag -v ，如git tag -v v1.5; 创建一个轻量级标签的话，就直接使用 git tag 命令即可，连-a,-s以及-m选项都不需要，直接给出标签名字即可，如git tag v1.5; 将标签推送到远程仓库中：git push origin ，如git push origin v1.5； 将本地所有的标签全部推送到远程仓库中：git push origin --tags; （三）Github 注册 Github 账号 略~ 多人协作开发流程 A 在自己的计算机中创建本地仓库 A 在 GitHub 中创建远程仓库 A 将本地仓库推送到远程仓库 B 克隆远程仓库到本地进行开发 B 将本地仓库开发内容推送到远程仓库 A 将远程仓库中的最新内容拉去本地 创建远程仓库 推送到远程仓库 git push 远程仓库地址 分支名称 git push 远程仓库地址别名 分支名称 git push -u 远程仓库地址别名 分支名称 -u 记住推送地址和分支，下次只需要输入git push git remote add 远程仓库地址别名 远程仓库地址 删除别名：git remote remove 远程仓库地址别名 第一次提交需要用户名和密码，电脑会记住密码在凭据管理器，第二次就不用了。 本地仓库上的操作 查看本地仓库关联的远程仓库：git remote；在克隆完每个远程仓库后，远程仓库默认为origin;加上-v的参数后，会显示远程仓库的url地址； 添加远程仓库，一般会取一个简短的别名：git remote add [remote-name] [url]，比如：git remote add example git://github.com/example/example.git; 从远程仓库中抓取本地仓库中没有的更新：git fetch [remote-name]，如git fetch origin;使用 fetch 只是将远端数据拉到本地仓库，并不自动合并到当前工作分支，只能人工合并。如果设置了某个分支关联到远程仓库的某个分支的话，可以使用git pull来拉去远程分支的数据，然后将远端分支自动合并到本地仓库中的当前分支； 将本地仓库某分支推送到远程仓库上：git push [remote-name] [branch-name]，如git push origin master；如果想将本地分支推送到远程仓库的不同名分支：git push :，如git push origin serverfix:awesomebranch;如果想删除远程分支：git push [romote-name] :，如git push origin :serverfix。这里省略了本地分支，也就相当于将空白内容推送给远程分支，就等于删掉了远程分支。 查看远程仓库的详细信息：git remote show origin； 修改某个远程仓库在本地的简称：git remote rename [old-name] [new-name]，如git remote rename origin org； 移除远程仓库：git remote rm [remote-name]； 拉取仓库 克隆仓库 克隆远程仓库到本地：git clone 仓库地址 拉取远程仓库中最新版本 拉取远程仓库最新版本到本地：git pull 远程仓库地址 分支名称 解决冲突 多人开发同一个项目时，如果两个人修改了同一个文件同一个地方 git pull 手动解决冲突 git push 跨团队协作 fork到自己的远程仓库 clone到本地进行修改 push到远程仓库 pull request发送给原作者 原作者查看commit 审核 原作者 merge pull request SSH 免密登录 生成密钥：ssh-keygen 密匙储存目录：C:\\User\\用户\\.ssh 公钥名称：id_rsa.pub 私钥名称：id_rsa Github 添加公钥 复制 SSH 地址： 设置 ssh 别名：$ git remote add origin_ssh SSH地址 远程推送：$ git push origin_ssh master ubuntu git 环境搭建以及通过 SSH 连接 Github（免密码）配置 Git 忽略清单 将不需要的文件名字添加到此文件中，执行 git 命令时就会忽略这些文件。 git 忽略清单文件名称：.gitignore 将工作目录所有文件添加到缓存区：git add . 例子： 12345678910111213# 此为注释 – 将被 Git 忽略# 忽略所有 .a 结尾的文件*.a# 但 lib.a 除外!lib.a# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO/TODO# 忽略 build/ 目录下的所有文件build/# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txtdoc/*.txt# 忽略 doc/ 目录下所有扩展名为 txt 的文件doc/**/*.txt 为仓库添加说明 在仓库根目录添加readme.md文件即可 （四）使用 SourceTree 管理 Git https://blog.csdn.net/u012230055/article/details/64125268 一 、SourceTree 简介 SourceTree 是 Windows 和 Mac OS X 下免费的 Git 和 Hg 客户端，拥有可视化界面，容易上手操作。同时它也是 Mercurial 和 Subversion版本控制系统工具。支持创建、提交、clone、push、pull 和 merge 等操作。 二、下载安装 SourceTree 步骤 下载地址：https://www.sourcetreeapp.com/，该版本是中文的，下载完成后可以进行安装。 点击“install”，安装完成后，打开 sourcetree，点击“user an existing account” 注意：使用谷歌帐号登录即可，前提是你必须可以上谷歌才可以。 直接点击“跳过初始设置”即可。 登录注册成功后，弹出设置 puttykey 的界面，点击“取消”即可。 点击“取消”按钮，弹出如下提示框： 此时进入到 sourcetree 的主界面，现在就可以使用 sourcetree 啦。 三、集成文件对比插件 安装对比插件 Sourcetree 中集成 Beyond Compare 4，当文件冲突时可以很好的解决冲突。安装过程很简单，这里不再详述。 Sourcetree 中配置 Beyond Compare 4 菜单栏，“工具”——“选项”，如图所示： 选择“比较”选项卡，然后将红色方框处的内容修改为如图所示： 四、SourceTree 基本使用 （1）克隆 点击克隆按钮，克隆项目： 既可以是本地已有的 git 项目，也可以是远程目录中的项目， 本地存在的 git 项目， 获取项目克隆地址，点击克隆按钮，如图所示： 1、克隆项目的路径 2、克隆项目存放的位置 3、如果要下载特定的分支，可以按分支进行下载 （2）配置忽略文件 利用.gitignore 过滤文件，如编译过程中的中间文件，等等，这些文件不需要被追踪管理。 .gitignore 文件只对还没有加入版本管理的文件起作用，如果之前已经用 git 把这些文件纳入了版本库，就不起作用了 使用 sourcetree 添加忽略文件的方法： 正常情况下，管理员创建项目后需要直接将忽略文件创建好。创建方法如图： 按照如上步骤操作即可编辑冲突文件。 冲突文件规则： 忽略文件夹（如：bin、obj）： obj/ bin/ 某目录下的所有.txt 文件， obj/*.txt 开发的过程中可能遇到一些忽略文件中未添加的文件，此时需要开发者自行添加忽略文件，添加方法如下： 之前已经介绍过未进行版本控制的或者受版本控制的文件，在 sourcetree 的“文件状态” 标签中查找，如图所示： 鼠标右键要忽略的文件，点击“忽略”，选择忽略的模式，即可将文件进行忽略，如图所示： （3）tag 使用方法 打 tag 的目的是在代码的主要节点处有个标记，方便下次修改代码时可以准确的找到想要找的代码。而无需看着日志文件逐一回忆要找的代码位置。 （4）分支管理与使用 使用 sourcetree 创建和使用分支是很方便的，不像之前使用的 TortoiseGit 只能在当前代码处创建分支，使用 sourcetree 的方便之处： 1、可以选择特定的某版本创建分支 2、代码检出时可以按照分支进行检出 3、分支的添加很简单 分支添加： 1、可以在当前的版本下创建分支 2、选择指定的提交创建分支 3、点击“创建分支” 分支提交到服务器： 在 sourcetree 右侧内容中的分支列表中，选中创建的分支，右键提交，如图所示： 分支合并： 1、分支合并功能和分支添加功能类似，这里不再详述，需要注意的是首先要切换到被合并的分支上，再进行合并操作。 2、分支合并时，可以选择具体的某提交进行合并，同时主分支可以合并到子分支；子分支可以合并到主分支；子分支之间也可以进行合并。 （5）GIT 与 SVN 同步 git svn 工具集在当前不得不使用 Subversion 服务器或者开发环境要求使用 Subversion 服务器的时候格外有用。不妨把它看成一个跛脚的 Git，在实际使用中不推荐这样使用 GIT。 （6）基本步骤 提交、拉取和推送 提交： 项目提交是为了维护本地版本库，如果本地有未提交的内容，则不允许拉取和推送；如图所示区域有内容时，则代表本地未提交的内容： 点击 Stage All，填写提交信息既可以将本地内容（暂存区）提交到本地版本库，如图所示： 1、将未暂存的文件进行暂存，如果有些文件不需要暂存，则可以进行删除，选中文件，右键“移除”即可。 拉取：从远程将代码进行更新，相当于 SVN 的“更新” 推送：将代码提交到远程。 （7）解决冲突 简单介绍 1、冲突文件的符号为“感叹号” 2、选中“冲突文件”，右键——点击”解决冲突“——点击”打开外部合并工具“（备注：才操作时已经安装外部合并工具，同时在 sourcetree 中已经进行配置，详见”集成文件对比插件“） 冲突界面 冲突解决界面如下：可以根据需要选择内容显示类型，只”显示更改“，”显示冲突“或者”全部“ 解决冲突 方法一：在相关的版本处，选中”冲突行”，合并区默认处于合并位置，鼠标右键，选择最终冲突地方留下的内容，如图： 解决冲突之后效果图： 1、冲突图标由”感叹号”——“省略号”。 2、右侧显示修改后的代码进行查看。 3、同时修改的冲突文件有相应的备份，大家可以下载到本地，方便冲突有问题再次修改文件。 备注：该文件下载之后请将版本库中的该文件删除，不要上传到版本库中。 4、修改完冲突之后，需要再次提交，推送。大家养成提交时，提交有效的日志信息，不要将比如：123 之类的信息推送到服务器中。 方法二：如果冲突非常少，可以直接在右侧栏中解决冲突，如图所示： 1、点击未暂存区域的冲突文件。 2、右侧列表中出现冲突的内容。 3、选择冲突内容，解决冲突，如图所示： 暂存行：表示保留该内容 丢弃行：表示删除该内容 备注：区分于第一种方式，使用第一种方法解决时，不要点击”未暂存文件”,否则可能无法打开冲突文件 （8）版本回退 原则上，代码推送之前要保证本地的代码可运行，不要将不可运行或者有问题的代码推送到服务器上，如果由于误操作，将代码推送到了远程，想重新修改上传代码，此时，需要将版本进行回退，回 退方法如图： 1、切换到日志/历史标签 2、选择要恢复到的版本，如图蓝色位置 3、鼠标右键，选择“重置当前分支到此次提交” 4、选择”重置模式”，如图所示 5、弹出框中选择”Yes” （9）相关提示信息含义 冲突信息 先更新信息 小窍门： 如果推送时，拉取右上方显示数字，则需要先拉取再推送。 五、SourceTree&amp;Git 部分名词解释 克隆(clone)：从远程仓库 URL 加载创建一个与远程仓库一样的本地仓库 提交(commit)：将暂存文件上传到本地仓库（我们在 Finder 中对本地仓库做修改后一般都得先提交一次，再推送） 检出(checkout)：切换不同分支 添加（add）：添加文件到缓存区 移除（remove）：移除文件至缓存区 暂存(git stash)：保存工作现场 重置(reset)：回到最近添加(add)/提交(commit)状态 合并(merge)：将多个同名文件合并为一个文件，该文件包含多个同名文件的所有内容，相同内容抵消 抓取(fetch)：从远程仓库获取信息并同步至本地仓库 拉取(pull)：从远程仓库获取信息并同步至本地仓库，并且自动执行合并（merge）操作，即 pull=fetch+merge 推送(push)：将本地仓库同步至远程仓库，一般推送（push）前先拉取（pull）一次，确保一致 分支(branch)：创建/修改/删除分枝 标签(tag):给项目增添标签 工作流(Git Flow):团队工作时，每个人创建属于自己的分枝（branch），确定无误后提交到 master 分枝 终端(terminal):可以输入 git 命令行 Git 设置，查看，取消代理 12345678910# 设置代理git config --global http.proxy &#x27;http://127.0.0.1:7890&#x27; # 这是设置的默认端口 7890git config --global https.proxy &#x27;http://127.0.0.1:7890&#x27;# 查看代理git config --global --get http.proxygit config --global --get https.proxy# 取消代理git config --global --unset http.proxygit config --global --unset https.proxy","categories":[{"name":"git","slug":"git","permalink":"https://www.hpstu.cn/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.hpstu.cn/tags/git/"}]},{"title":"bash","slug":"bash","date":"2022-03-06T04:16:37.000Z","updated":"2022-05-01T12:56:57.721Z","comments":true,"path":"bash.html","link":"","permalink":"https://www.hpstu.cn/bash.html","excerpt":"","text":"bash 执行方式 脚本执行方式： 直接输入文件及其路径（绝对路径或者相对路径） 12./haha.sh /home/hp/桌面/haha.sh 也可以将脚本文件作为参数传给Shell程序，使其解释并执行脚本文件的·内容 1bash ./haha.sh 还可以使用source命令执行文件 1source ./haha.sh 如果文件没权限执行则添加权限 1sudo chmod +x ./haha.sh 注意变量赋值等号( = )之间不能有空格 12n=10 #Truen = 10 #False Shell是一种弱类型的编程语言。(类似Python) 重定向 与 Unix 主题“任何东西都是一个文件”保持一致，程序，比方说 ls，实际上把他们的运行结果输送到一个叫做标准输出的特殊文件（经常用 stdout 表示），而它们的状态信息则送到另一个叫做标准错误的文件（stderr）。默认情况下，标准输出和标准错误都连接到屏幕，而不是保存到磁盘文件。除此之外，许多程序从一个叫做标准输入（stdin）的设备得到输入，默认情况下，标准输入连接到键盘。I/O 重定向允许我们更改输出地点和输入来源。一般地，输出送到屏幕，输入来自键盘，但是通过 I/O 重定向，我们可以做出改变。I/O 重定向允许我们来重定义标准输出的地点。我们使用 “&gt;” 重定向符后接文件名将标准输出重定向到除屏幕以外的另一个文件。为什么我们要这样做呢？因为有时候把一个命令的运行结果存储到一个文件很有用处。例如，我们可以告诉 shell 把 ls 命令的运行结果输送到文件 ls-output.txt 中去，由文件代替屏幕。 1ls -l /usr/bin &gt; ls-output.txt 这里，我们创建了一个长长的目录/usr/bin 列表，并且输送程序运行结果到文件 ls-output.txt 中。 程序不把它的错误信息输送到标准输出。反而，像许多写得不错的 Unix 程序，ls 把错误信息送到标准错误。 命令的组合符&amp;&amp;和|| 除了分号，Bash 还提供两个命令组合符&amp;&amp;和||，允许更好地控制多个命令之间的继发关系。 1Command1 &amp;&amp; Command2 上面命令的意思是，如果Command1命令运行成功，则继续运行Command2命令。 1Command1 || Command2 上面命令的意思是，如果Command1命令运行失败，则继续运行Command2命令。 快捷键 Bash 提供很多快捷键，可以大大方便操作。下面是一些最常用的快捷键，完整的介绍参见《行操作》一章。 Ctrl + L：清除屏幕并将当前行移到页面顶部。 Ctrl + C：中止当前正在执行的命令。 Shift + PageUp：向上滚动。 Shift + PageDown：向下滚动。 Ctrl + U：从光标位置删除到行首。 Ctrl + K：从光标位置删除到行尾。 Ctrl + D：关闭 Shell 会话。 ↑，↓：浏览已执行命令的历史记录 ctrl+A 跳到光标所在行的行首 ctrl+E 跳到光标所在行的行尾 ctrl+W 删除光标前的单个域 Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。 变量声明的语法如下。 1variable=value 上面命令中，等号左边是变量名，右边是变量。注意，等号两边不能有空格。 如果变量的值包含空格，则必须将值放在引号中。 1myvar=&quot;hello world&quot; Shebang 行 脚本的第一行通常是指定解释器，即这个脚本必须通过什么解释器执行。这一行以#!字符开头，这个字符称为 Shebang，所以这一行就叫做 Shebang 行。 #!后面就是脚本解释器的位置，Bash 脚本的解释器一般是/bin/sh或/bin/bash。 123#!/bin/sh# 或者#!/bin/bash #!与脚本解释器之间有没有空格，都是可以的。 如果 Bash 解释器不放在目录/bin，脚本就无法执行了。为了保险，可以写成下面这样。 1#!/usr/bin/env bash 上面命令使用env命令（这个命令总是在/usr/bin目录），返回 Bash 可执行文件的位置。env命令的详细介绍，请看后文。 Shebang 行不是必需的，但是建议加上这行。如果缺少该行，就需要手动将脚本传给解释器。举例来说，脚本是script.sh，有 Shebang 行的时候，可以直接调用执行。 1$ ./script.sh 上面例子中，script.sh是脚本文件名。脚本通常使用.sh后缀名，不过这不是必需的。 如果没有 Shebang 行，就只能手动将脚本传给解释器来执行。 123$ /bin/sh ./script.sh# 或者$ bash ./script.sh 1234567# 给所有用户执行权限$ chmod +x script.sh# 给所有用户读权限和执行权限$ chmod +rx script.sh# 或者$ chmod 755 script.sh 脚本的权限通常设为755（拥有者有所有权限，其他人有读和执行权限）或者700（只有拥有者可以执行）。 建议在主目录新建一个~/bin子目录，专门存放可执行脚本，然后把~/bin加入$PATH。 12export PATH=$PATH:~/bin# “ ：“(冒号)是 PATH 的分隔符（上面相当于赋值操作了） 上面命令改变环境变量$PATH，将~/bin添加到$PATH的末尾。可以将这一行加到~/.bashrc文件里面，然后重新加载一次.bashrc，这个配置就可以生效了。 1$ source ~/.bashrc 以后不管在什么目录，直接输入脚本文件名，脚本就会执行。 1$ script.sh 上面命令没有指定脚本路径，因为script.sh在$PATH指定的目录中。 source 命令 source命令用于执行一个脚本，通常用于重新加载一个配置文件。 1$ source .bashrc source命令最大的特点是在当前 Shell 执行脚本，不像直接执行脚本时，会新建一个子 Shell。所以，source命令执行脚本时，不需要export变量。 123#!/bin/bash# test.shecho $foo 上面脚本输出$foo变量的值。 123456789# 当前 Shell 新建一个变量 foo$ foo=1# 打印输出 1$ source test.sh1# 打印输出空字符串$ bash test.sh 上面例子中，当前 Shell 的变量foo并没有export，所以直接执行无法读取，但是source执行可以读取。 source命令的另一个用途，是在脚本内部加载外部库。 12345#!/bin/bashsource ./lib.shfunction_from_lib 上面脚本在内部使用source命令加载了一个外部库，然后就可以在脚本里面，使用这个外部库定义的函数。 source有一个简写形式，可以使用一个点（.）来表示。 1$ . .bashrc","categories":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.hpstu.cn/categories/ubuntu/"}],"tags":[{"name":"bash","slug":"bash","permalink":"https://www.hpstu.cn/tags/bash/"}]},{"title":"Ubuntu 命令","slug":"ubuntu","date":"2022-03-06T02:54:21.000Z","updated":"2022-05-01T13:19:12.026Z","comments":true,"path":"ubuntu.html","link":"","permalink":"https://www.hpstu.cn/ubuntu.html","excerpt":"","text":"Ubuntu 命令 1、文件/文件夹管理 ls 列出当前目录下的所有文件（不显示隐藏文件）listq cd 或者 cd ~进入用户主目录 Change Directory cd -返回进入此目录之前所在的目录 mkdir dirname 新建目录 Make Directory rmdir dirname 删除空目录 rm filename 删除文件Remove Directory rm -rf dirname 删除非空目录及其包含的所有文件 mv file1 file2将文件1重命名为文件2 mv file1 dir1 将文件1移动到目录1中 find 路径 -name “字符串” 查找路径所在范围内满足字符串匹配的文件和目录 sudo su 转到管理员权限执行命令 pwd指出当前所在的路径。是print working directory的缩写。 cat 查看ubuntu中文本文件的内容 concatenate cat file1 file2&gt;&gt;file3 把文件1和文件2的内容联合起来放到 file3中 su 切换用户 switch user ps (-auxf) 进程状态，类似于 windows 的任务管理器 process status df 其功能是显示磁盘可用空间数目信息及空间结点信息 disk free ln -s 创建一个软链接，相当于创建一个快捷方式 ink -soft man 命令手册 manual chown change owner chgrp change group chmod change mode tar tape archive 文件结尾的&quot;rc&quot;（如.bashrc、.xinitrc 等）：Resource configuration c++ 文件扩展名后缀： .a（扩展名 a）：Archive，static library .so（扩展名 so）：Shared object，dynamically linked library .o（扩展名 o）：Object file，complied result of C/C++ source file apt：Advanced package tool | grep：Global Regular Expression Print， 全局正则表达式版本 目录： /bin = BInaries /dev = Devices /etc = Etcetera ; Editable Text Configuration, 可编辑文本配置， 便成了专门放置系统配置文件的目录 /lib = LIbrary /proc = Processes /sbin = Superuser Binaries /tmp = Temporary /usr = Unix Shared Resources /var = Variable ? 2、程序安装与卸载 chmod 用于改为用户对于文件的操作权限 remove 卸载指定的程序，一般最好加上“–purge”执行清除式卸载；并在程序名称后添加*号。举例：sudo apt-get remove --purge nvidia* 卸载 nvidia 的驱动及其配置文件 update 更新本地软件源文件，需要管理员权限，举例：sudo apt-get update 3、打包/解压 这里需要先解释几个参数。 参数 含义 参数 含义 -c 建立压缩档案 -z 有gzip属性的 -t 查看内容 -j 有bz2属性的 -u 更新原压缩包中的文件 -Z 有compress属性的 -x 解压 -v 显示所有过程 -r 向压缩归档文件末尾追加文件 -O 将文件解开到标准输出 上表左边五个参数是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。右边五个参数是根据需要在压缩或解压时可选的。 下面进行举例说明。 压缩 tar -cvf jpg.tar *.jpg 将目录里所有jpg文件打包成tar.jpg tar -czf jpg.tar.gz *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz tar -cjf jpg.tar.bz2 *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2 tar -cZf jpg.tar.Z *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z rar a jpg.rar *.jpg rar格式的压缩，需要先下载rar for linux zip jpg.zip *.jpg zip格式的压缩，需要先下载zip for linux 解压 tar -xvf file.tar 解压 tar包 tar -xzvf file.tar.gz 解压tar.gz tar -xjvf file.tar.bz2 解压 tar.bz2 tar -xZvf file.tar.Z 解压tar.Z unrar e file.rar 解压rar unzip file.zip 解压zip 总结 .tar 用 tar -xvf 解压 .gz 用 gzip -d或者gunzip 解压 .tar.gz和.tgz 用 tar -xzf 解压 .bz2 用 bzip2 -d或者用bunzip2 解压 .tar.bz2用tar -xjf 解压 .Z 用 uncompress 解压 .tar.Z 用tar -xZf 解压 .rar 用 unrar e解压 .zip 用 unzip 解压 4、用户管理 sudo useradd username 创建一个新的用户username sudo passwd username 设置用户username的密码 sudo groupadd groupname 创建一个新的组groupname sudo usermod -g groupname username 把用户username加入到组groupname中 sudo chown username:groupname dirname 将指定文件的拥有者改为指定的用户或组 5、系统管理 uname -a 查看内核版本 cat /etc/issue 查看ubuntu版本 sudo fdisk -l 查看磁盘信息 df -h 查看硬盘剩余空间 free -m 查看当前的内存使用情况 ps -A 查看当前有哪些进程 kill 进程号或者 killall 进程名 杀死进程 kill -9 进程号 强制杀死进程 设置 conda代理： 原本是空白文件 1sudo gedit ~/.condarc 在文件中添加代理端口： 123proxy_servers: http: http://127.0.0.1:7890 https: https://127.0.0.1:7890","categories":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.hpstu.cn/categories/ubuntu/"}],"tags":[{"name":"ubuntu命令","slug":"ubuntu命令","permalink":"https://www.hpstu.cn/tags/ubuntu%E5%91%BD%E4%BB%A4/"}]},{"title":"cmake","slug":"cmake","date":"2022-03-05T13:47:10.000Z","updated":"2022-05-01T13:02:15.224Z","comments":true,"path":"cmake.html","link":"","permalink":"https://www.hpstu.cn/cmake.html","excerpt":"","text":"CMake模板 12345678910111213141516171819202122232425262728293031323334353637383940414243## 设置cmake版本cmake_minimum_required(VERSION 3.16)## 设置生成项目名称project(MyProject)## 设置c++标准set(CMAKE_CXX_STANDARD 11)## set Debug or ReleaseSET(CMAKE_BUILD_TYPE Release)## 追加cmake查找目录# LIST(APPEND CMAKE_MODULE_PATH $&#123;PROJECT_SOURCE_DIR&#125;/cmake_modules)## 控制输出路径# set (CMAKE_ARCHIVE_OUTPUT_DIRECTORY $&#123;path_dir&#125;) # 1. 默认存放静态库的文件夹位置# set (CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;path_dir&#125;) # 2. 默认存放动态库的文件夹位置# set (LIBRARY_OUTPUT_PATH $&#123;path_dir&#125;) # 3. 默认存放库文件的位置，如果产生的是静态库并且没有指定CMAKE_ARCHIVE_OUTPUT_DIRECTORY 则存放在该目录下，动态库也类似； # set (CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;path_dir&#125;) # 4. 存放可执行软件的目录；## 查找库文件find_package(OpenCV 3 REQUIRED)## 添加头文件目录include_directories(#include: $&#123;OpenCV_INCLUDE_DIRS&#125;)## 生成lib库set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/lib)aux_source_directory(./src DIR_SRCS)add_library($&#123;PROJECT_NAME&#125; $&#123;DIR_SRCS&#125;)target_link_libraries($&#123;PROJECT_NAME&#125; # lib_path: $&#123;OpenCV_LIBRARY_DIRS&#125; )## 添加子目录#add_subdirectory(src)#add_subdirectory(example)# Build examplesset(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/example)add_executable(test example/app.cpp)target_link_libraries(test $&#123;PROJECT_NAME&#125;) 执行：project(MyProject)，就是定义了一个项目的名称为：MyProject，对应的 就会生成两个变量：&lt;projectname&gt;_BINARY_DIR和&lt;projectname&gt;_SOURCE_DIR，但是cmake中其实已经有两个预定义的变量：PROJECT_BINARY_DIR和PROJECT_SOURCR_DIR 获取文件路径中所有的源文件：aux_sourcr_directory(&lt;dir&gt; &lt;variable&gt;) example:将当前目录下的源文件名字存放到变量DIR_SRCS里面aux_sourcr_directory(. DIR_SRCS) 变量和缓存 局部变量 CMakeLists.txt相当于一个函数，第一个执行的CMakeLists.txt相当于主函数，正常设置的变量不能跨越CMakeLists.txt文件，相当于局部变量只在当前函数域里面作用一样， 设置变量：set(MY_VARIABLE &quot;value&quot;) 变量的名称通常大写 访问变量：$&#123;MY_VARIABLE&#125; 缓存变量 缓存变量就是cache变量，相当于全局变量，都是在第一个执行的CMakeLists.txt里面被设置的，不过在子项目的CMakeLists.txt文件里面也是可以修改这个变量的，此时会影响父目录的CMakeLists.txt，这些变量用来配置整个工程，配置好之后对整个工程使用。 环境变量 设置环境变量：set(ENV&#123;variable_name&#125; value) 获取环境变量：$ENV&#123;variable_name&#125; 内置变量","categories":[{"name":"C++","slug":"C","permalink":"https://www.hpstu.cn/categories/C/"}],"tags":[{"name":"cmake","slug":"cmake","permalink":"https://www.hpstu.cn/tags/cmake/"}]},{"title":"Github + Hexo 搭建个人博客超详细教程","slug":"1","date":"2020-02-18T13:17:35.000Z","updated":"2022-05-01T13:09:09.826Z","comments":true,"path":"1.html","link":"","permalink":"https://www.hpstu.cn/1.html","excerpt":"","text":"前言 作为一名计算机爱好者，摸索了一周搭建出自己的博客。目前只学 习了c语言，没有任何前端知识和网站开发经验，总的来说，算不上很难， 但也要费些心思。网上各类教程应有尽有，只要肯摸索，还是水到渠成的事。另外，写下这篇文章，记录下自己的经验，给需要的朋友，祝你早日拥有自己的博客！ 搭建博客的初衷是希望用博客记录下自己的学习过程，帮助自己复习，分享一部分不成熟的思考，敦促自己把既定的目标完成。 为什么要搭建自己的博客？可以看看这三篇文章： 《为什么你应该（从现在开始就）写博客》 (By 刘未鹏 | Mind Hacks) 《为什么要自建博客？》 (By 知乎) 《我为什么写博客》 （By 知明所以） 我们需要知道搭建博客要用到的框架。Hexo是高效的静态站点生成框架，它基于Node.js。我们使用MarkDown在本地编辑我们的博客文章，通过Hexo生成静态页面，再用两条命令即可部署到我们的网站。无需关心网页源代码的具体细节，我们只需要用心写好自己的博客内容就行。 本文目录 快速搭建 安装Node.js 添加国内镜像 安装Git 注册Github账号 创建Git仓库 安装Hexo 配置本地Hexo 连接Github与本地 写文章、发布文章 MarkDown文章编辑器说明 配置个性化域名 更换自己喜欢的Hexo主题 我的博客源代码 结语 快速搭建 有的朋友可能不想去折腾，自定义主题也比较麻烦，亦或有尝试几次搭建却失败，那就可以看这部分。快速搭建可以帮助我们更快搭建出自己的博客，优点是别人博客有的东西你都有，就跟复制差不多；缺点是博客里的配置信息都是别人的，不过不要紧，稍稍改改配置就可以。 在这里以我的博客为例。 一、下载博客源代码 大家可以直接素质二连，Star&amp;Fork我的博客源代码：https://github.com/MUYIio/hexo-themes-matery，这里我给出两种下载方法： 第一种：直接DownLoad，下载到本地就可以。（不推荐） 第二种：如果你已经安装了Git，就可以右键单击Come Bash Here运行 1git clone git@github.com:MUYIio/hexo-themes-matery.git 将所有文件下载到本地，这个复杂一点。 二、修改博客文档配置 首先将我们下载的博客源代码解压，然后修改主要配置： 根目录配置文件_config.yml和主题目录配置文件_config.yml中修改个人信息。 根目录配置文件中修改deploy一栏的repository。 根目录配置文件中修改baidu_url_submit一栏的token。 主题配置文件中修改gitalk一栏，修改方法见正文。 我给出的是博客比较明显的几个地方，先修改这几个地方，其它的可以自己慢慢摸索修改。 最后一步，本地的运行环境还是需要搭建好的，跟着下文操作到连接Github与本地，环境就算是搭建完成。 本地环境搭建好之后会生成的文件： 然后直接把Hexo文件夹里面的文件删掉，把我的源代码的文件全部移动过来，就是这样了： 然后在Hexo文件夹下右键单击鼠标，点击 Git Bash Here点击输入以下命令上传就可以了： hexo clean hexo g hexo d 安装Node.js 了解一下什么是Node.js： Node.js就是一个用于创建服务器端应用程序的运行系统，它可以轻松构建网络或其他事件驱动的应用程序服务器。 需要用到的命令： $ git --version $ node -v $ npm -v 点击此处进入Node.js官网下载相应版本即可，安装时选项全部默认，一路点击Next。 检验是否安装成功： 按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功了。 添加国内镜像 这里我们使用阿里的国内镜像进行加速，按Win+R打开命令提示符输入： npm config set registry https://registry.npm.taobao.org 安装Git Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理，帮助我们把本地网页上传到Github。 点击此处进入Git官网下载相应版本，默认安装即可。 参考资料：《如何在windows下安装GIT》 (By 俊雨廷休) 检验是否安装成功： 安装完成后在命令提示符中输入git --version验证是否安装成功 git --version 注册Github账号 Github作为全球最大的开源社区，相信朋友们都已经有了吧，如果没有，点击此处进入Github官网点击 Sign Up 注册账户。 创建git仓库 登录Github创建一个仓库 如下图所示，输入自己的项目名字，后面一定要加.github.io后缀，README初始化也要勾上。名称一定要和你的Github名字完全一样，比如你github名字叫A，那么仓库名字一定要是A.github.io。 选择一个自己喜欢的主题： 在上面创建的仓库里面点击Settings（不是头像下面那个Settings），向下拉到最后有个GitHub Pages，点击Choose a theme选择一个主题。然后等一会儿，再回到GitHub Pages，就可以预览效果啦。 安装Hexo Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。 选择一个磁盘，新建一个文件夹用来存放博客文件。比如我的（C/panakot Blog），在该文件夹下右键单击鼠标，点击 Git Bash Here，输入以下 npm 命令即可安装 $ npm install hexo-cli -g 输入hexo -v即可检验是否安装成功，我这里就不演示了。 配置本地hexo 还是在刚才新建的文件夹下再新建一个Hexo文件夹，比如我的（C/panakot Blog/Hexo），在Hexo文件夹下右键单击鼠标，点击 Git Bash Here，依次输入以下 npm 命令即可初始化。 hexo init npm install 初始化成功生成的文件： 接着我们输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开http://localhost:4000/，就可以预览我们的博客啦，如图： 显示以下信息说明操作正确： INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 按ctrl+c关闭本地服务器。 我们以后常用到的Hexo命令： hexo s等价于 hexo server #Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。 hexo g 等价于 hexo generate #生成静态网页 (执行 $ hexo g后会在站点根目录下生成public文件夹, hexo会将&quot;/blog/source/&quot; 下面的.md后缀的文件编译为.html后缀的文件,存放在&quot;/blog/public/ &quot; 路径下) hexo d 等价于 hexo deploy #将本地数据部署到远端服务器(如github) hexo clean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹 连接Github与本地 一、生成密钥 右键单击鼠标，点击 Git Bash Here输入以下命令： git config --global user.name &quot;Name&quot; git config --global user.email &quot;Email&quot; Name和Email是我们注册Github时的用户名和邮箱。 然后生成密钥： ssh-keygen -t rsa -C &quot;Email&quot; Email是我们注册Github时的邮箱 然后会出现： Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): //到这里可以直接回车将密钥按默认文件进行存储 回车之后： Enter passphrase (empty for no passphrase): //这里是要你输入密码，其实不需要输什么密码，直接回车就行 Enter same passphrase again: 接下来会有： Your identification has been saved in /c/Users/you/.ssh/id_rsa. Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub. The key fingerprint is: 这里是各种字母数字组成的字符串，结尾是你的邮箱 The key's randomart image is: 这里也是各种字母数字符号组成的字符串 现在密钥已经生成，一般存放在（/c/Users/you/.ssh/id_rsa.pub.），我们运行下面的命令将密钥复制为粘贴板： clip &lt; ~/.ssh/id_rsa.pub 二、连接Github 在Github头像下面点击Settings，再点击SSH and GPG keys，新建一个SSH，名字任意。 然后将刚才复制的密钥添加就可以了，像这样： 本地连接Github 右键单击鼠标，点击 Git Bash Here输入以下命令，如果如下图所示，出现你的用户名，那就成功了 ssh -T git@github.com //注意不要做任何修改 用记事本打开博客根目录下的_config.yml文件，这是博客的配置文件，我们需要修改一下才能连接Github。 修改最后一行的配置： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: 改为： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repository: git@github.com:panakot/panakot.github.io.git branch: master 切记： repository修改为你自己的github项目地址。 每一个冒号后面都有一个空格。 写文章、发布文章 首先在博客根目录下右键打开Git Bash Here输入以下命令，安装一个扩展. npm i hexo-deployer-git 然后输入下面的命令，新建一篇文章。 hexo new post &quot;article title&quot; 然后打开C:\\panakot Blog\\Hexo\\source_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。 编写完markdown文件后，根目录下右键打开Git Bash Here输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。 你的博客地址：https://你的用户名.github.io，比如我的是：https://muyiio.github.io，现在每个人都可以通过此链接访问你的博客 MarkDown文章编辑器说明 前面我们提到了使用MarkDown编辑我们的博客文章。 Markdown 是 2004 年由 John Gruberis 设计和开发的纯文本格式的语法，非常的简单实用，常用的标记符号屈指可数，几分钟即可学会， .md 文件可以使用支持 Markdown 语法的编辑器编辑，然后将写好的文章（.md文件）保存到 \\Hexo\\source_posts 文件夹下即可。 Windows 上推荐使用 MarkdownPad2 或者小书匠编辑器，macOS 上使用 Mou 编辑器，Linux 上使用 Remarkable 编辑器，Web 端上使用 简书。 点击此处下载MarkDown ，刚使用的朋友或许不知道如何使用这个编辑器，只需要几分钟就可以掌握啦，给出以下几个我觉得不错的参考： 《献给写作者的 Markdown 新手指南》 （By 简书） 《Markdown语法图文全面详解(10分钟学会)》（By 黑暗星球） 《Markdown 语法手册 （完整整理版）》 （By witnessai1） 《认识与入门 Markdown》（By Te_Lee） 写完文章记得在博客根目录Bash Here输入hexo g和hexo d上传到网站。 配置个性化域名 一顿操作下来，打开我们的博客还是：www.xxx.github.io，是不是很没有牌面？我们可以考虑购买一个专属域名，以后打开博客就是这样：www.xxx.com 。 阿里云和腾讯云都可以，我的是腾讯云，购买域名后首先需要添加解析： **方法一：**点击添加记录，需要添加两个记录，两个记录类型都是 CNAME ，第一个主机记录为 @ ，第二个主机记录为 www，记录值都是填你自己的博客地址（比如我的是：muyiio.github.io），保存之后域名解析就完成了！ **方法二：**两个记录类型为 A ，第一个主机记录为 @ ，第二个主机记录为 www，记录值都为博客的 IP 地址，IP 地址可以 cmd 中输入 ping 你的博客地址 获得（比如我的：ping muyiio.github.io），保存之后域名解析就完成了！ 参考资料： 《域名解析中A记录、CNAME、MX记录、NS记录的区别和联系》 不管在哪个平台购买域名，操作都大同小异，这里说明两点： 如果你填写的是没有www的，比如 muyio.com，那么无论是访问 https://www.muyiio.com 还是 https://muyiio.com ，都会自动跳转到 https://muyiio.com。 如果你填写的是带www的，比如 www.muyiio.com ，那么无论是访问 https://www.muyiio.com 还是 https://muyiio.com ，都会自动跳转到 http://www.imuyiio.com。 然后打开你的github博客项目，点击settings，拉到下面Custom domain处，填上你自己的域名，保存就可以了。 现在我们的项目根目录应该会出现一个名为CNAME的文件了。如果没有的话，打开你本地博客/source目录，我的是C:\\Blog\\Hexo\\source，新建CNAME文件，（注意不要加.txt，没有任何后缀名！）。然后在里面写上你的域名，保存。最后运行hexo g、hexo d上传到github。 现在就可以通过我们的个性化域名：www.xxx.com、xxx.com访问自己的博客了。 更换自己喜欢的Hexo主题 点击进入Hexo主题专栏可以看到很多Hexo主题： 推荐： 几个好用的hexo主题 (By fail_perfectly) 这里我们以Bean Tech主题为例，下滑到底部我们可以看到他的GitHub（有的主题是：Theme by xxx，点击那里也是进入GitHub地址）： 点击进入主题的GitHub地址： 复制该项目地址： 然后打开 Hexo 文件夹下的 themes 目录（如：C:\\MUYIio Blog\\Hexo\\themes），右键 Git Bash Here，输入以下命令： $ git clone 此处填写你刚才复制的主题地址 以我们刚才复制的为例： $ git clone https://github.com/Huxpro/huxpro.github.io 下载完成后即可在 themes 目录下生成 hexo-theme-Bean-Tech 文件夹，然后打开 Hexo 文件夹下的配置文件 _config.yml ，找到关键字 theme，修改参数为：theme：hexo-theme-Bean-Tech （其他主题修改成相应名称即可），再次注意冒号后面有一个空格！ 现在我们的主题已经替换完成，将它部署到我们的博客，博客根目录下右键 Git Bash Here，输入以下命令： hexo clean hexo g hexo d 现在访问我们的网站就可以看到主题已经更换了，但是比如网站标题，图标等都没有更换，我们博客文件中有两份主要的配置文件，名称都是 _config.yml ，它们均是用于站点配置使用的。其中，一份位于站点根目录下（比如我的：C:\\MUYIio Blog\\Hexo_config.yml），主要包含 Hexo 本身整站的配置；另一份位于主题目录下（比如我的：C:\\MUYIio Blog\\Hexo\\themes\\hexo-theme-matery_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项，一般 _config.yml 文件里都有相关注释，按需修改即可。 我的博客源代码 我的博客源代码地址：https://github.com/MUYIio/hexo-themes-matery，有心的话可以给个Star&amp;Fork。 下载源代码：git clone git@github.com:MUYIio/hexo-themes-matery.git 在文章开头给出了快速搭建教程，相对于自己从头开始搭建还是比较方便的，修复了很多Bug，也添加了一些插件，下载就可以使用，可以帮你们省去个性化配置带来的很多麻烦。 主题的原地址在这里：hexo-theme-matery，作者把文档写得也非常的详细，还有中英文两个版本，建议可以多看几遍，在本地修改的时候轻松一些。 使用我的源代码之前本地的环境还是要搭建好，就是前面一部分。 结语 初学者可能会觉得困难，毕竟很多东西都是第一次接触，当初我也尝试了好几次才成功，不要放弃，弄错了就删掉重新来过，当你把博客搭建出来会觉得受益良多的。 文章中难免有错误的地方，有大佬发现了欢迎给我指正！有的地方解释不够详细，可以百度一下看看细节，文章中的引用以及参考资料涉及侵权请联系我删除！","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.hpstu.cn/categories/Blog/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.hpstu.cn/tags/Hexo/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://www.hpstu.cn/categories/python/"},{"name":"软件工具","slug":"软件工具","permalink":"https://www.hpstu.cn/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"},{"name":"C++","slug":"C","permalink":"https://www.hpstu.cn/categories/C/"},{"name":"SLAM","slug":"SLAM","permalink":"https://www.hpstu.cn/categories/SLAM/"},{"name":"Markdown","slug":"Markdown","permalink":"https://www.hpstu.cn/categories/Markdown/"},{"name":"git","slug":"git","permalink":"https://www.hpstu.cn/categories/git/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.hpstu.cn/categories/ubuntu/"},{"name":"Blog","slug":"Blog","permalink":"https://www.hpstu.cn/categories/Blog/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"https://www.hpstu.cn/tags/python%E5%9F%BA%E7%A1%80/"},{"name":"clion","slug":"clion","permalink":"https://www.hpstu.cn/tags/clion/"},{"name":"STL","slug":"STL","permalink":"https://www.hpstu.cn/tags/STL/"},{"name":"g2o","slug":"g2o","permalink":"https://www.hpstu.cn/tags/g2o/"},{"name":"李群李代数","slug":"李群李代数","permalink":"https://www.hpstu.cn/tags/%E6%9D%8E%E7%BE%A4%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"name":"VINS","slug":"VINS","permalink":"https://www.hpstu.cn/tags/VINS/"},{"name":"C++文件操作","slug":"C-文件操作","permalink":"https://www.hpstu.cn/tags/C-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"name":"C++模板","slug":"C-模板","permalink":"https://www.hpstu.cn/tags/C-%E6%A8%A1%E6%9D%BF/"},{"name":"C++内置库","slug":"C-内置库","permalink":"https://www.hpstu.cn/tags/C-%E5%86%85%E7%BD%AE%E5%BA%93/"},{"name":"RANSAC","slug":"RANSAC","permalink":"https://www.hpstu.cn/tags/RANSAC/"},{"name":"容器","slug":"容器","permalink":"https://www.hpstu.cn/tags/%E5%AE%B9%E5%99%A8/"},{"name":"指针","slug":"指针","permalink":"https://www.hpstu.cn/tags/%E6%8C%87%E9%92%88/"},{"name":"Markdown","slug":"Markdown","permalink":"https://www.hpstu.cn/tags/Markdown/"},{"name":"Eigen","slug":"Eigen","permalink":"https://www.hpstu.cn/tags/Eigen/"},{"name":"C++多线程","slug":"C-多线程","permalink":"https://www.hpstu.cn/tags/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"C++面向对象","slug":"C-面向对象","permalink":"https://www.hpstu.cn/tags/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"C++关键字","slug":"C-关键字","permalink":"https://www.hpstu.cn/tags/C-%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"git","slug":"git","permalink":"https://www.hpstu.cn/tags/git/"},{"name":"bash","slug":"bash","permalink":"https://www.hpstu.cn/tags/bash/"},{"name":"ubuntu命令","slug":"ubuntu命令","permalink":"https://www.hpstu.cn/tags/ubuntu%E5%91%BD%E4%BB%A4/"},{"name":"cmake","slug":"cmake","permalink":"https://www.hpstu.cn/tags/cmake/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.hpstu.cn/tags/Hexo/"}]}