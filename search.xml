<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[VINSnote]]></title>
      <url>/vinsnote.html</url>
      <content type="html"><![CDATA[<h1 id="vins笔记"><a class="markdownIt-Anchor" href="#vins笔记"></a> VINS笔记</h1>
<h2 id="编程实现四元数和李代数更新"><a class="markdownIt-Anchor" href="#编程实现四元数和李代数更新"></a> 编程实现四元数和李代数更新</h2>
<p>可以使用四元数或旋转矩阵存储旋转变量。当我们用计算出来的 ω对某旋转更新时，有两种不同方式：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><msup><mi mathvariant="bold">R</mi><mi mathvariant="bold">′</mi></msup></mrow><mo>←</mo><mrow><mi mathvariant="bold">R</mi></mrow><mspace width="0.16667em"></mspace><mi>exp</mi><mrow><mo>(</mo><mrow><mover accent="true"><mrow><mi>ω</mi></mrow><mo>^</mo></mover></mrow><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\bold{R^\prime}\leftarrow \bold{R}\,\exp{({\hat{\omega}})}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.801892em;"></span><span class="strut bottom" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord displaystyle textstyle uncramped"><span class="mord"><span class="mord mathbf">R</span><span class="vlist"><span style="top:-0.413em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathbf">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mrel">←</span><span class="mord displaystyle textstyle uncramped"><span class="mord mathbf">R</span></span><span class="mord mspace thinspace"></span><span class="mop">exp</span><span class="mord displaystyle textstyle uncramped"><span class="mopen">(</span><span class="mord displaystyle textstyle uncramped"><span class="mord accent"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle cramped"><span class="mord mathit" style="margin-right:0.03588em;">ω</span></span></span><span style="top:0em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="accent-body"><span>^</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">OR
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mi mathvariant="normal">′</mi><mo>←</mo><mi>q</mi><mo>⨂</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></mfrac><mi>ω</mi><msup><mo>]</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">q\prime\leftarrow q\bigotimes[1,\frac{1}{2}\omega]^T
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.32144em;"></span><span class="strut bottom" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">q</span><span class="mord mathrm">′</span><span class="mrel">←</span><span class="mord mathit" style="margin-right:0.03588em;">q</span><span class="op-symbol large-op mop" style="top:-0.000004999999999977245em;">⨂</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mord mathit" style="margin-right:0.03588em;">ω</span><span class="mclose"><span class="mclose">]</span><span class="vlist"><span style="top:-0.413em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化旋转矩阵</span></span><br><span class="line">    Eigen:: Matrix3d R=Eigen::<span class="built_in">AngleAxisd</span>(M_PI/<span class="number">4</span>,Eigen::<span class="built_in">Vector3d</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)).<span class="built_in">toRotationMatrix</span>();</span><br><span class="line">    std::cout&lt;&lt;R.<span class="built_in">matrix</span>()&lt;&lt;std::endl;</span><br><span class="line">    <span class="function">Quaterniond <span class="title">q</span><span class="params">(R)</span></span>;</span><br><span class="line">    <span class="function">Sophus::SO3d <span class="title">SO3_R</span><span class="params">(R)</span></span>;</span><br><span class="line">    <span class="function">Sophus::SO3d <span class="title">SO3_q</span><span class="params">(q)</span></span>;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;SO(3) from matrix: &quot;</span>&lt;&lt; SO3_R.<span class="built_in">matrix</span>()&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;SO3 from quaternion&quot;</span>&lt;&lt; SO3_q.<span class="built_in">matrix</span>()&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector3d <span class="title">update_w</span><span class="params">(<span class="number">0.01</span>,<span class="number">0.02</span>,<span class="number">0.03</span>)</span></span>;<span class="comment">//更新量</span></span><br><span class="line">    Sophus::SO3d SO3_updated = SO3_R * Sophus::SO3d::<span class="built_in">exp</span>(update_w);<span class="comment">//右乘更新</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;SO3_updated = &quot;</span>&lt;&lt; endl &lt;&lt; SO3_updated.<span class="built_in">matrix</span>()&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">Quaterniond <span class="title">update_q</span><span class="params">(<span class="number">1</span>, update_w(<span class="number">0</span>) / <span class="number">2</span>, update_w(<span class="number">1</span>) / <span class="number">2</span>, update_w(<span class="number">2</span>) / <span class="number">2</span>)</span></span>;  <span class="comment">//[1,1/2w]</span></span><br><span class="line">    update_q.<span class="built_in">normalize</span>();<span class="comment">//归一化处理</span></span><br><span class="line">    Eigen::Quaterniond q_updated=q * update_q;</span><br><span class="line">    <span class="comment">//q_updated.normalize();//note:对更新量单独归一化或者更新完进行归一化都可以，结果一致</span></span><br><span class="line">    <span class="function">Sophus::SO3d <span class="title">SO3_q_updated</span><span class="params">(q_updated)</span></span>;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;SO3_q_updated = &quot;</span>&lt;&lt; endl &lt;&lt; SO3_q_updated.<span class="built_in">matrix</span>()&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="VINSnote%5Cquaternion.png" alt="quaternion" /></p>
<p><img src="https://img-blog.csdnimg.cn/20191123115613193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MTcwNjI2,size_16,color_FFFFFF,t_70" alt="" /><br />
<img src="https://img-blog.csdnimg.cn/20191123115656646.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MTcwNjI2,size_16,color_FFFFFF,t_70" alt="" /></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[C++ Tips]]></title>
      <url>/ctips.html</url>
      <content type="html"><![CDATA[<h2 id="文件操作"><a class="markdownIt-Anchor" href="#文件操作"></a> 文件操作</h2>
<p>文件类型分为两种：</p>
<ol>
<li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li>
<li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li>
</ol>
<p>操作文件的三大类:</p>
<ol>
<li>ofstream：写操作</li>
<li>ifstream： 读操作</li>
<li>fstream ： 读写操作</li>
</ol>
<p><code>ofstream ofs</code> 默认打开方式是<code>ios::out</code>，</p>
<p><code>ofs &lt;&lt; &quot;balabala&quot;</code></p>
<p><code>ifstream ifs</code>默认打开方式是<code>ios:in</code></p>
<p><code>ifs &gt;&gt; str</code></p>
<p><code>&gt;&gt;</code>,<code>&lt;&lt;</code> 箭头的朝向表示数据流到哪。一般文件流在前面。</p>
<p>文件<strong>打开方式</strong>：</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>ios::in</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
</tbody>
</table>
<h3 id="文本文件"><a class="markdownIt-Anchor" href="#文本文件"></a> 文本文件</h3>
<ol>
<li>写文件步骤如下：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>					<span class="comment">// 包含头文件     </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ofstream ofs;					<span class="comment">// 创建流对象</span></span><br><span class="line">    ofs.<span class="built_in">open</span>((<span class="string">&quot;文件路径&quot;</span>,打开方式)	   <span class="comment">// 打开文件 （信息就保存在ofs这个流对象里了）</span></span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;写入数据&quot;</span>;</span><br><span class="line">    ...</span><br><span class="line">    ofs.<span class="built_in">close</span>();					<span class="comment">// 关闭文件，内容就刷新到文件里了         </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()&#123;</span><br><span class="line">    ofstream <span class="built_in">ofs</span>(<span class="string">&quot;文件路径&quot;</span>,打开方式)	<span class="comment">// 调用构造方式。</span></span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;写入数据&quot;</span>;</span><br><span class="line">    ...</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;             </span><br></pre></td></tr></table></figure>
<ol start="2">
<li>读文件步骤如下：</li>
</ol>
<p>读文件与写文件步骤相似，但是读取方式相对于比较多</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种方式</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs &gt;&gt; buf)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs.getline(buf,sizeof(buf)))</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种</span></span><br><span class="line">	<span class="comment">//string buf;</span></span><br><span class="line">	<span class="comment">//while (getline(ifs, buf))</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++模板]]></title>
      <url>/c-mo-ban.html</url>
      <content type="html"><![CDATA[<h1 id="c-模板"><a class="markdownIt-Anchor" href="#c-模板"></a> C++ 模板</h1>
<h2 id="函数模板"><a class="markdownIt-Anchor" href="#函数模板"></a> 函数模板</h2>
<p>模板函数与普通函数的区别：</p>
<ul>
<li>函数模板<strong>不允许</strong>自动类型转换 ， 但传入实参时可以自动进行类型推导，不用加<code>&lt;type &gt;</code></li>
<li>普通函数能够自动进行类型转换</li>
</ul>
<p>同名函数优先调用普通函数，除非显式加<code>&lt; type&gt;</code></p>
<h2 id="类模板"><a class="markdownIt-Anchor" href="#类模板"></a> 类模板</h2>
<p>调用时，类模板必须显示式指定类型</p>
<p><strong>类模板派生普通类</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()&#123;</span><br><span class="line">        mAge = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T mAge;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 派生类为普通类,需要指定类型 &lt;int&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubPerson1</span> : <span class="keyword">public</span> Person&lt;<span class="type">int</span>&gt;&#123;				</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 派生类为模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubPerson2</span> : <span class="keyword">public</span> Person&lt;T&gt;&#123;				</span><br><span class="line">    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>不要滥用友元</p>
<p>类模板<code>.h</code>文件·和<code>.cpp</code>文件分离编译在调用是会引发二次编译问题，所以一半将声明和实现都放在一个文件里，定义成<code>.hpp</code>文件。</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C++内置库以及函数]]></title>
      <url>/c-nei-zhi-ku-he-han-shu.html</url>
      <content type="html"><![CDATA[<h1 id="C-内置库以及函数"><a href="#C-内置库以及函数" class="headerlink" title="C++内置库以及函数"></a>C++内置库以及函数</h1><h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><ol>
<li><strong>定义</strong></li>
</ol>
<blockquote>
<p>sizeof是一个操作符（operator）。</p>
<p>其作用是返回一个对象或类型所占的<strong>内存字节数</strong>。</p>
</blockquote>
<ol start="2">
<li><strong>语法</strong></li>
</ol>
<blockquote>
<p>sizeof有三种语法形式：</p>
<pre class="line-numbers language-c++"><code class="language-c++">1） sizeof (object); //sizeof (对象)
2） sizeof object;  //sizeof 对象
3） sizeof (type_name); //sizeof (类型)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>对象可以是各种类型的变量，以及表达式（一般sizeof不会对表达式进行计算）。</p>
<p>sizeof对对象求内存大小，最终都是转换为对对象的数据类型进行求值。</p>
<p>sizeof (表达式); &#x2F;&#x2F;值为表达式的最终结果的数据类型的大小</p>
</blockquote>
<ul>
<li><p><strong>基本数据类型的sizeof</strong></p>
<ul>
<li><p>这里的基本数据类型是指short、int、long、float、double这样的简单内置数据类型。</p>
<p>由于它们的内存大小是和系统相关的，所以在不同的系统下取值可能不同。</p>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">int i;  
sizeof(int); //值为4  
sizeof(i); //值为4，等价于sizeof(int)  
sizeof i; //值为4  
sizeof(2); //值为4，等价于sizeof(int)，因为2的类型为int  
sizeof(2 + 3.14); //值为8，等价于sizeof(double)，因为此表达式的结果的类型为double  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p><strong>结构体的sizeof</strong></p>
<ul>
<li><p>结构体的sizeof涉及到字节对齐问题。</p>
<p>为什么需要字节对齐？计算机组成原理教导我们这样有助于加快计算机的取数速度，否则就得多花指令周期了。为此，编译器默认会对结构体进行处理（实际上其它地方的数据变量也是如此），让宽度为2的基本数据类型（short等）都位于能被2整除的地址上，让宽度为4的基本数据类型（int等）都位于能被4整除的地址上，依次类推。这样，两个数中间就可能需要加入填充字节，所以整个结构体的sizeof值就增长了。</p>
<p>注意：空结构体（不含数据成员）的sizeof值为1。试想一个“不占空间“的变量如何被取地址、两个不同的“空结构体”变量又如何得以区分呢，于是，“空结构体”变量也得被存储，这样编译器也就只能为其分配一个字节的空间用于占位了。</p>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">struct S1  
&#123;  
    char a;  
    int b;  
&#125;;  
sizeof(S1); //值为8，字节对齐，在char之后会填充3个字节。  
  
struct S2  
&#123;  
&#125;;  
sizeof(S2); //值为1，空结构体也占内存
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p><strong>数组的sizeof</strong></p>
<p>数组的sizeof值等于数组所占用的内存字节数。</p>
<p>注意：1）<strong>当字符数组表示字符串时，其sizeof值将’&#x2F;0’计算进去。</strong></p>
<p>​           2）<strong>当数组为形参时，其sizeof值相当于指针的sizeof值。</strong></p>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">char a[10];  
char n[] = "abc";   
  
cout<<"char a[10] "<<sizeof(a)<<endl;//数组，值为10  
  
cout<<"char n[] = abc "<<sizeof(n)<<endl;//字符串数组，将'/0'计算进去，值为4
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p><strong>指针的sizeof</strong></p>
<p>指针是用来记录另一个对象的地址，所以指针的内存大小当然就等于计算机内部地址总线的宽度。</p>
<p>在32位计算机中，一个指针变量的返回值必定是4。</p>
<p><strong>指针变量的sizeof值与指针所指的对象没有任何关系。</strong></p>
</li>
</ul>
<h2 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C++字符串"></a>C++字符串</h2><p>C++大大增强了对字符串的支持，除了可以使用C风格的字符串，还可以使用内置的 string 类。string 类处理起字符串来会方便很多，完全可以代替C语言中的字符数组或字符串指针</p>
<p>string 是 C++ 中常用的一个类</p>
<p>使用 string 类需要包含头文件<code>&lt;string&gt;</code>，下面的例子介绍了几种定义 string 变量（对象）的方法：</p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>
#include <string>
using namespace std;

int main()&#123;
    string s1;
    string s2 = "c plus plus";
    string s3 = s2;
    string s4 (5, 's');
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>变量 s1 只是定义但没有初始化，编译器会将默认值赋给 s1，默认值是<code>&quot;&quot;</code>，也即空字符串。</p>
<p>变量 s2 在定义的同时被初始化为<code>&quot;c plus plus&quot;</code>。与C风格的字符串不同，string 的结尾<strong>没有结束标志</strong><code>&#39;\0&#39;</code>。</p>
<p>变量 s3 在定义的时候直接用 s2 进行初始化，因此 s3 的内容也是<code>&quot;c plus plus&quot;</code>。</p>
<p>变量 s4 被初始化为由 5 个<code>&#39;s&#39;</code>字符组成的字符串，也就是<code>&quot;sssss&quot;</code>。</p>
<p>从上面的代码可以看出，string 变量可以直接通过赋值操作符<code>=</code>进行赋值。string 变量也可以用C风格的字符串进行赋值，例如，s2 是用一个字符串常量进行初始化的，而 s3 则是通过 s2 变量进行初始化的。</p>
</blockquote>
<ul>
<li><p>转换为C风格的字符串：</p>
<p>虽然 C++ 提供了 string 类来替代C语言中的字符串，但是在实际编程中，有时候必须要使用C风格的字符串（例如打开文件时的路径），为此，string 类为我们提供了一个转换函数 c_str()，该函数能够将 string 字符串转换为C风格的字符串，并返回该字符串的 const 指针（const char*）。</p>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">string path = "D:\\demo.txt";
FILE* fp = fopen(path.c_str(), "rt"); // FILE是一个结构体，fopen参数为c风格字符串，该函数返回一个指向 FILE 结构的指针。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>为了使用C语言中的 fopen() 函数打开文件，必须将 string 字符串转换为C风格的字符串。</strong></p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
            <category> 内置库和函数 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[RANSAC]]></title>
      <url>/ransac.html</url>
      <content type="html"><![CDATA[<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>对于N个点构成的集合P，我们假定最少通过n个点可以拟合出正确的模型，也就是说样本集合中有N − n个噪声点。具体的执行下列操作：</p>
<ol>
<li>从数据集中随机选择一组最小样本拟合模型H，</li>
<li>使用其他所有数据验证模型并从中取出符合阈值的内点，</li>
<li>如果内点数量达到阈值则保存该次所有内点，否则抛弃步骤2中的内点，执行步骤4，</li>
<li>重复以上步骤k次（即迭代k次）并更新内点（即保存步骤2中的最多内点）【可设置提前退出迭代机制，即内点足够多时退出（很难判断）】</li>
<li>然后使用最小二乘法重新拟合模型（步骤4中的所有内点）</li>
</ol>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><ol>
<li>初始内点的确定</li>
</ol>
<p>算法第1步中选择内点时，通常选择能确定模型的最少点，比如两点确定一条直线，3点确定一个平面。在求解单应性矩阵的时候，就是4个点对8个点确定一个矩阵模型。</p>
<ol start="2">
<li>迭代次数的确定</li>
</ol>
<p>通常来说N的值比较大，那么随机选择点的时候，点与点的组合就很多，如果不对迭代次数进行限制，运算量就会很大。因为算法第2步要用剩余点对模型进行测试，如果点的数量较多，这一步的运算量很大。包括后面的第3，4步。其实我们只要保证我们估计模型的时候使用的都是内点即可。</p>
<p>假设是内点的概率为$p$:</p>
<p>$$p&#x3D; \frac{n_i}{n_i + n_o}$$</p>
<p> $n_i$为内点数量,$n_o$ 为外点数量。那么我们每次计算模型使用$n$个点的情况下，选取的点集中至少有一个外点的概率就是：$1 - t^n$那么在迭代$k$次的情况下，$(1-t^n)^k$就是次迭代都至少有1个外点的概率。<br>那么能够得到$n$个正确的点来估计模型的概率就是：</p>
<p>$$P&#x3D;1 - (1 - t^n)^t$$</p>
<p>两边取对数，就可以得到最少迭代次数:</p>
<p>$$k &#x3D; \frac{\log(1-P)}{\log(1-t^n)}$$</p>
<p>这里$P$是希望通过算法得到正确模型的最少概率，$k$是关于$P$单调递增的,$k$就是在$P$确定情况下的最少迭代次数。$t$通常未知，那么我们可以采用自适应的办法，在开始的时候设置一个较大的迭代次数$k$，然后通过每次迭代中更新$t$来更新迭代次数。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>这里使用RANSAC算法来拟合直线:python代码如下：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt
<span class="token keyword">import</span> random
<span class="token keyword">import</span> math

<span class="token keyword">class</span> <span class="token class-name">ransacMatchingTest</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">,</span> Y<span class="token punctuation">,</span> sigma<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span> prob<span class="token operator">=</span><span class="token number">0.95</span><span class="token punctuation">)</span><span class="token punctuation">:</span>

        self<span class="token punctuation">.</span>X <span class="token operator">=</span> X
        self<span class="token punctuation">.</span>Y <span class="token operator">=</span> Y
        self<span class="token punctuation">.</span>sigma <span class="token operator">=</span> sigma
        self<span class="token punctuation">.</span>prob <span class="token operator">=</span> prob

    <span class="token keyword">def</span> <span class="token function">runMatch</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>

        preInlier <span class="token operator">=</span> <span class="token number">0</span>
        iters <span class="token operator">=</span> <span class="token number">10000</span>
        best_a <span class="token operator">=</span> <span class="token number">0</span>
        best_b <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>iters<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true"># sample points</span>
            sampleIndex <span class="token operator">=</span> random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
            x1 <span class="token operator">=</span> self<span class="token punctuation">.</span>X<span class="token punctuation">[</span>sampleIndex<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
            y1 <span class="token operator">=</span> self<span class="token punctuation">.</span>Y<span class="token punctuation">[</span>sampleIndex<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

            x2 <span class="token operator">=</span> self<span class="token punctuation">.</span>X<span class="token punctuation">[</span>sampleIndex<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
            y2 <span class="token operator">=</span> self<span class="token punctuation">.</span>Y<span class="token punctuation">[</span>sampleIndex<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

            <span class="token comment" spellcheck="true"># Compute mode</span>
            a <span class="token operator">=</span> <span class="token punctuation">(</span>y2 <span class="token operator">-</span> y1<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>x2 <span class="token operator">-</span> x1<span class="token punctuation">)</span>
            b <span class="token operator">=</span> y1 <span class="token operator">-</span> a <span class="token operator">*</span> x1

            <span class="token comment" spellcheck="true"># Get number of inlier</span>
            inlier <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token keyword">for</span> index <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                y_estimate <span class="token operator">=</span> a <span class="token operator">*</span> self<span class="token punctuation">.</span>X<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">+</span> b
                <span class="token keyword">if</span> abs<span class="token punctuation">(</span>y_estimate <span class="token operator">-</span> self<span class="token punctuation">.</span>Y<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>sigma<span class="token punctuation">:</span>
                    inlier <span class="token operator">=</span> inlier <span class="token operator">+</span> <span class="token number">1</span>

            <span class="token keyword">if</span> inlier <span class="token operator">></span> preInlier<span class="token punctuation">:</span>
                <span class="token comment" spellcheck="true"># Update iteration times</span>
                iters <span class="token operator">=</span> math<span class="token punctuation">.</span>log<span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>self<span class="token punctuation">.</span>prob<span class="token punctuation">)</span> <span class="token operator">/</span> math<span class="token punctuation">.</span>log<span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> pow<span class="token punctuation">(</span>inlier <span class="token operator">/</span> self<span class="token punctuation">.</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 这句好像没起作用</span>
                preInlier <span class="token operator">=</span> inlier
                best_a <span class="token operator">=</span> a
                best_b <span class="token operator">=</span> b
            <span class="token comment" spellcheck="true"># While inliers over half of input set then break</span>
            <span class="token keyword">if</span> inlier <span class="token operator">></span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">break</span>

        <span class="token keyword">return</span> best_a<span class="token punctuation">,</span> best_b

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    X <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span>
    Y <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">*</span> X <span class="token operator">+</span> <span class="token number">6</span>

    randomX <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    randomY <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment" spellcheck="true"># Add mode noise</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        randomX<span class="token punctuation">.</span>append<span class="token punctuation">(</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        randomY<span class="token punctuation">.</span>append<span class="token punctuation">(</span>Y<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># Add random noise</span>
    <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        randomX<span class="token punctuation">.</span>append<span class="token punctuation">(</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        randomY<span class="token punctuation">.</span>append<span class="token punctuation">(</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    RANDOMX <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>randomX<span class="token punctuation">)</span>
    RANDOMY <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>randomY<span class="token punctuation">)</span>

    ransac <span class="token operator">=</span> ransacMatchingTest<span class="token punctuation">(</span>RANDOMX<span class="token punctuation">,</span> RANDOMY<span class="token punctuation">,</span> sigma<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span> prob<span class="token operator">=</span><span class="token number">0.95</span><span class="token punctuation">)</span><span class="token punctuation">.</span>runMatch<span class="token punctuation">(</span><span class="token punctuation">)</span>

    preY <span class="token operator">=</span> ransac<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> RANDOMX <span class="token operator">+</span> ransac<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>

    fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>
    ax1 <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    ax1<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>RANDOMX<span class="token punctuation">,</span> RANDOMY<span class="token punctuation">)</span>

    ax1<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>RANDOMX<span class="token punctuation">,</span> preY<span class="token punctuation">)</span>
    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      
        <categories>
            
            <category> SLAM </category>
            
            <category> RANSAC </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RANSAC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++容器]]></title>
      <url>/c-rong-qi.html</url>
      <content type="html"><![CDATA[<h1 id="c容器"><a class="markdownIt-Anchor" href="#c容器"></a> C++容器</h1>
<h2 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> vector</h2>
<blockquote>
<p>vector是STL中最常见的容器，它是一种顺序容器，支持随机访问。vector是一块连续分配的内存，从数据安排的角度来讲，和数组极其相似，不同的地方就是：数组是静态分配空间，一旦分配了空间的大小，就不可再改变了；而vector是动态分配空间，随着元素的不断插入，它会按照自身的一套机制不断扩充自身的容量。</p>
</blockquote>
<blockquote>
<p>vector的扩充机制：按照容器现在容量的一倍进行增长。vector容器分配的是一块连续的内存空间，每次容器的增长，并不是在原有连续的内存空间后再进行简单的叠加，而是重新申请一块更大的新内存，并把现有容器中的元素逐个复制过去，然后销毁旧的内存。</p>
</blockquote>
<blockquote>
<p>vector数据结构，采用的是连续的线性空间，属于线性存储.</p>
</blockquote>
<ol>
<li><code>vector</code>对象的定义和初始化</li>
</ol>
<table>
<thead>
<tr>
<th>操作调用方式</th>
<th>操作说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Vector&lt;T&gt; v1;</code></td>
<td><code>Vector</code>保存类型为T的对象。默认构造函数<code>v1</code>为空</td>
</tr>
<tr>
<td><code>Vector&lt;T&gt; v2(v1);</code></td>
<td><code>V2</code>是<code>v1</code>的一个副本</td>
</tr>
<tr>
<td><code>Vector&lt;T&gt; v3(n , i);</code></td>
<td><code>V3</code>包含n个值为i的元素</td>
</tr>
<tr>
<td><code>Vector&lt;T&gt; v4(n);</code></td>
<td><code>V4</code>含有值初始化的元素的n个副本</td>
</tr>
</tbody>
</table>
<p>注：对C++的容器来说，动态添加元素的效率，要比直接静态初始化元素的效率高</p>
<p>例1.1 :声明一个int向量以替代一维的数组:<code>vector &lt;int&gt; a;</code>(等于声明了一个int数组a[],大小没有指定,可以动态的向里面添加删除)。</p>
<p>例1.2: 用<code>vector</code>代替二维数组.其实只要声明一个一维数组向量即可,而一个数组的名字其实代表的是它的首地址,所以只要声明一个地址的向量即可,即:<code>ector &lt;int *&gt; a</code>.</p>
<ol start="2">
<li>对象的操作</li>
</ol>
<table>
<thead>
<tr>
<th>操作调用方式</th>
<th>操作说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>v.empty()</code></td>
<td>判断v是否为空</td>
</tr>
<tr>
<td><code>v.size()</code></td>
<td>返回v中元素的个数</td>
</tr>
<tr>
<td><code>v.push_back(t)</code></td>
<td>向v的末尾添加一个元素</td>
</tr>
<tr>
<td><code>V[n]</code></td>
<td>返回v中位置为n的元素</td>
</tr>
<tr>
<td><code>V1 = v2</code></td>
<td>把v1中元素替换为v2中元素副本</td>
</tr>
<tr>
<td><code>V1==v2</code></td>
<td>判断是否相等</td>
</tr>
<tr>
<td><code>!=, &lt;, &lt;=, &gt;, &gt;=</code></td>
<td>直接用于vector对象的相互比较</td>
</tr>
</tbody>
</table>
<blockquote>
<p>1.push_back  在数组的最后添加一个数据<br />
2.pop_back  去掉数组的最后一个数据<br />
<a href="http://3.at">3.at</a>        得到编号位置的数据<br />
4.begin      得到数组头的指针<br />
5.end       得到数组的最后一个单元+1的指针<br />
6．front    得到数组头的引用<br />
7.back      得到数组的最后一个单元的引用<br />
8.max_size   得到vector最大可以是多大<br />
9.capacity    当前vector分配的大小<br />
10.size      当前使用数据的大小<br />
11.resize     改变当前使用数据的大小，如果它比当前使用的大，者填充默认值<br />
12.reserve   改变当前vecotr所分配空间的大小<br />
13.erase     删除指针指向的数据项<br />
14.clear     清空当前的vector<br />
15.rbegin    将vector反转后的开始指针返回(其实就是原来的end-1)<br />
16.rend     将vector反转构的结束指针返回(其实就是原来的begin-1)<br />
17.empty    判断vector是否为空<br />
18.swap     与另一个vector交换数据</p>
</blockquote>
<h2 id="string"><a class="markdownIt-Anchor" href="#string"></a> string</h2>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
            <category> 容器 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[c++指针]]></title>
      <url>/c-zhi-zhen.html</url>
      <content type="html"><![CDATA[<h1 id="C-指针-amp-函数"><a href="#C-指针-amp-函数" class="headerlink" title="C++指针&amp;函数"></a>C++指针&amp;函数</h1><h2 id="复杂类型解析"><a href="#复杂类型解析" class="headerlink" title="复杂类型解析"></a>复杂类型解析</h2><p>一个类型里会出现很多运算符,他们也像普通的表达式一样,有优先级,其优先级和运算优先级一样,</p>
<p>解析原则:<strong>从变量名处起,根据运算符优先级结合,一步一步分析</strong>.（括号的优先级比<code>*</code>优先级高）</p>
<pre class="line-numbers language-c++"><code class="language-c++">int p; //这是一个普通的整型变量
int *p; //首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针
int p[3]; //首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组
int *p[3]; //首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组
int (*p)[3]; //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与"()"这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针
int **p; //首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.
int p(int); //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据
Int (*p)(int); //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针
int *(*p(int))[3]; //可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">int *p[3];
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>首先从变量<code>p</code>开始看起，<code>p</code>与<code>[]</code>结合，说明<code>p</code>是一个数组，那么就要问了，这个数据里放的数据是什么类型，欸，与最近的<code>*</code>结合，说明这个数组里的数据是指针，那么又要问了，这个指针指向什么类型，哦，原来指的是<code>int</code>类型，那么结果就出来了。</p>
<pre class="line-numbers language-c++"><code class="language-c++">int (*p)[3]; 
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>同理: <code>p</code>是一个指针，这个指针指向一个数组，这个数组的类型是<code>int</code>型。</p>
<h2 id="函数基本知识"><a href="#函数基本知识" class="headerlink" title="函数基本知识"></a>函数基本知识</h2><p>C++对于返回值的类型有一定的限制：不能是数组，可以是其它任何类型–整数、浮点数、指针、结构和对象。（数组可以作为结构、对象组成部分来返回）</p>
<p><strong>在C++中，当（且仅当）用于函数头或函数原型中，int * arr和int arr[ ] 的含义才相同，都意味着arr是一个int指针。</strong></p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
            <category> 指针 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown语法]]></title>
      <url>/markdown-yu-fa.html</url>
      <content type="html"><![CDATA[<h1 id="Markdown格式"><a href="#Markdown格式" class="headerlink" title="Markdown格式"></a>Markdown格式</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用 <strong>#</strong> 号可表示 1-6 级标题，一级标题对应一个 <strong>#</strong> 号，二级标题对应两个 <strong>#</strong> 号，以此类推。</p>
<pre class="line-numbers language-sh"><code class="language-sh"># 一级标题
## 二级标题
### 三级标题
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>显示效果：</p>
<blockquote>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3></blockquote>
<h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>编辑模式下可以在段落后面使用一个空行来表示重新开始一个段落。</p>
<pre class="line-numbers language-sh"><code class="language-sh">chapter1

chapter2
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>可以使用以下几种字体：</p>
<pre class="line-numbers language-sh"><code class="language-sh">*斜体文本*
_斜体文本_
**粗体文本**
__粗体文本__
***粗斜体文本***
___粗斜体文本___
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>显示效果：</p>
<blockquote>
<p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em></p>
</blockquote>
<h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。</p>
<pre><code>***
---
___
</code></pre>
<p>显示效果：</p>
<blockquote>
<hr>
<hr>
<hr>
</blockquote>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <strong>~~</strong> 即可</p>
<pre><code>~~haha~~
</code></pre>
<p>显示效果：</p>
<blockquote>
<p><del>haha</del></p>
</blockquote>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>下划线可以通过 HTML 的 <strong><u></strong> 标签来实现：</p>
<pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>u</span><span class="token punctuation">></span></span>带下划线文本<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>u</span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>显示效果：</p>
<blockquote>
<p><u>带下划线文本</u></p>
</blockquote>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>支持有序列表和无序列表。</p>
<p>无序列表使用星号(<em>****)、加号(<strong>+</strong>)或是减号(</em>*-**)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p>
<pre class="line-numbers language-sh"><code class="language-sh">* 第一项

+ 第一项

- 第一项
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>有序列表使用数字并加上<code>.</code>号来表示</p>
<h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p>
<h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>区块引用是在段落开头使用 <code>&gt;</code> 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p>
<pre><code>&gt; 区块引用
</code></pre>
<p>显示结果：</p>
<blockquote>
<p>区块引用</p>
</blockquote>
<p>另外区块是可以嵌套的，一个<code>&gt;</code> 符号是最外层，两个 <code>&gt;</code> 符号是第一层嵌套，以此类推：</p>
<pre><code>&gt; 最外层
&gt; &gt; 第一层嵌套
&gt; &gt; &gt; 第二层嵌套
</code></pre>
<blockquote>
<p>最外层</p>
<blockquote>
<p> 第一层嵌套</p>
<blockquote>
<p>第二层嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<p>另外，在区块中可以保持其他语法的格式效果</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>使用 ``` 表示 或者 ` 表示
</code></pre>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><pre class="line-numbers language-sh"><code class="language-sh">[链接名称](链接地址)

或者

<链接地址>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a href="http://hpstu.github.io/">这是一个链接</a></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><ul>
<li>开头一个感叹号 !</li>
<li>接着一个方括号，里面放上图片的替代文字</li>
<li>接着一个普通括号，里面放上图片的网址（或者文件地址，最好使用相对地址），最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。</li>
</ul>
<pre><code>![alt 属性文本](图片地址)

![alt 属性文本](图片地址 &quot;可选标题&quot;)
</code></pre>
<p> 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <img> 标签。</p>
<pre><code>&lt;img src=&quot;http://static.runoob.com/images/runoob-logo.png&quot; width=&quot;50%&quot;&gt;
</code></pre>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>制作表格使用 <strong>|</strong> 来分隔不同的单元格，使用 <strong>-</strong> 来分隔表头和其他行。</p>
<pre class="line-numbers language-sh"><code class="language-sh">|  表头   | 表头  |
|  ----  | ----  |
| 单元格  | 单元格 |
| 单元格  | 单元格 |
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>我们可以设置表格的对齐方式：</strong></p>
<ul>
<li><strong>-:</strong> 设置内容和标题栏居右对齐。</li>
<li><strong>:-</strong> 设置内容和标题栏居左对齐。</li>
<li><strong>:-:</strong> 设置内容和标题栏居中对齐。</li>
</ul>
<pre><code>| 左对齐 | 右对齐 | 居中对齐 |
| :-----| ----: | :----: |
| 单元格 | 单元格 | 单元格 |
| 单元格 | 单元格 | 单元格 |
</code></pre>
<h2 id="支持的-HTML-元素"><a href="#支持的-HTML-元素" class="headerlink" title="支持的 HTML 元素"></a>支持的 HTML 元素</h2><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p>
<p>目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等 </p>
<p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p>
<h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>使用反斜杠转义特殊字符：</p>
<pre><code>\
</code></pre>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>待更…</p>
]]></content>
      
        <categories>
            
            <category> Markdown </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Eigen]]></title>
      <url>/eigen.html</url>
      <content type="html"><![CDATA[<h1 id="Eigen"><a href="#Eigen" class="headerlink" title="Eigen"></a>Eigen</h1><pre class="line-numbers language-c++"><code class="language-c++">a = a.transpose(); // !!! do NOT do this !!!
// For in-place transposition, as for instance in a = a.transpose(), simply use the transposeInPlace() function:
a.transposeInPlace();
//  Eigen treats matrix multiplication as a special case and takes care of introducing a temporary here, so it will compile m=m*m as:
// tmp = m*m;
// m = tmp;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++"><code class="language-C++">#include <iostream>
#include <Eigen/Dense>
 
using namespace std;
int main()
&#123;
  Eigen::Matrix2d mat;
  mat << 1, 2,
         3, 4;
  cout << "Here is mat.sum():       " << mat.sum()       << endl;
  cout << "Here is mat.prod():      " << mat.prod()      << endl;
  cout << "Here is mat.mean():      " << mat.mean()      << endl;
  cout << "Here is mat.minCoeff():  " << mat.minCoeff()  << endl;
  cout << "Here is mat.maxCoeff():  " << mat.maxCoeff()  << endl;
  cout << "Here is mat.trace():     " << mat.trace()     << endl;
&#125;
/*
Here is mat.sum():       10
Here is mat.prod():      24
Here is mat.mean():      2.5
Here is mat.minCoeff():  1
Here is mat.maxCoeff():  4
Here is mat.trace():     5
*/
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      
        <categories>
            
            <category> SLAM库 </category>
            
            <category> Eigen </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[c++多线程]]></title>
      <url>/c-duo-xian-cheng.html</url>
      <content type="html"><![CDATA[<h1 id="c多线程"><a class="markdownIt-Anchor" href="#c多线程"></a> C++多线程</h1>
<p>引入头文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>  </span></span><br></pre></td></tr></table></figure>
<p>链接库：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(xxx pthread)</span><br></pre></td></tr></table></figure>
<p><strong>线程</strong><br />
• 进程可以包含多个线程<br />
• 主线程：从main函数开始，main函数执行完，主线程结束，进程结束<br />
• 其他线程：需要我们自己创建，入口可以是函数、类、lambda表达式<br />
• 进程是否执行完毕的标志是：主线程是否执行完，如果主线程执行完毕了，就代表整个进程执行完<br />
了，一般来说，此时如果其他子线程还没有执行完，也会被强行终止</p>
<h2 id="创建子线程"><a class="markdownIt-Anchor" href="#创建子线程"></a> 创建子线程</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::thread	<span class="comment">// 多线程类</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">thrad <span class="title">th1</span><span class="params">(xx)</span></span>;		<span class="comment">// 使用其创建子线程对象的时候，子线程就直接运行了。</span></span><br><span class="line">    ...</span><br><span class="line">	th1.<span class="built_in">join</span>();			<span class="comment">// 汇合，表示等待子线程运行完，主线程再接着运行。（小溪汇入大河）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">thrad <span class="title">th2</span><span class="params">(xx)</span></span>;		<span class="comment">// 使用其创建子线程对象的时候，子线程就直接运行了。</span></span><br><span class="line">    ...</span><br><span class="line">	th2.<span class="built_in">detach</span>();		<span class="comment">// 分离，表示子线程脱离子线程，各走各的，互不相关（分流了），注意，此时如果主线程运行完毕，则直接关闭所有线程，子线程没运行完也停止运行。（夭折了），少用。</span></span><br><span class="line">    </span><br><span class="line">    th2.<span class="built_in">joinable</span>()		<span class="comment">// joinable()判断是否可以成功使用join()或者detach(),如果返回true，证明可以调用join()或者detach(),如果返回false，证明调用过join()或者detach()，join()和detach()都不能再调用了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看线程ID:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this_thread::<span class="built_in">get_id</span>()	<span class="comment">//  this_thread是一个namespace,</span></span><br></pre></td></tr></table></figure>
<h2 id="进程间安全防止读写冲突就给它上锁"><a class="markdownIt-Anchor" href="#进程间安全防止读写冲突就给它上锁"></a> 进程间安全（防止读写冲突，就给它上锁）</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>  <span class="comment">// 互斥锁头文件 ，mutex也是一个对象，相当于一把锁。</span></span></span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<p>先创建一个锁对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutex myMutex;</span><br></pre></td></tr></table></figure>
<p>上锁是防止多个线程<strong>同时</strong>对<strong>同一个数据快</strong>进行读写，造成冲突，（也就是前一个线程刚写入一半数据，你就过来读了），正确姿势是等他写完你再读，或读完你再写。所以，当其中一个线程拿到一把锁时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程1</span></span><br><span class="line">myMutex.<span class="built_in">lock</span>();			</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;putInData 子线程：放入一个数据&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">dataQuene.<span class="built_in">push_back</span>(i);</span><br><span class="line">myMutex.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程2</span></span><br><span class="line">myMutex.<span class="built_in">lock</span>();			</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;takeOutData 子线程：取出一个数据&quot;</span> &lt;&lt; dataQuene.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">dataQuene.<span class="built_in">pop_front</span>();</span><br><span class="line">myMutex.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>
<p>这两个线程为互斥关系，各自当执行到<code>myMutex.lock()</code>时，必须等一个拿到锁的代码快完整执行到释放锁<code>myMutex.unlock()</code>了，另一个才可能拿到锁继续执行。</p>
<blockquote>
<p>注意：<code>lock()</code>与<code>unlock()</code>必须成对出现，锁定后不解锁，或者重复解锁都会出问题</p>
</blockquote>
<p><strong>lock_guard</strong></p>
<ul>
<li>内部构造时相当于执行了lock，析构时相当于执行unlock</li>
<li>简单但不如lock()和unlock()灵活，通过大括号来实现，控制生命周期</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mutex myMutex;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">dataGuard</span><span class="params">(myMutex)</span></span>;		<span class="comment">// lock_guard&lt;mutex&gt;创建对象，参数为锁对象</span></span><br><span class="line">	...</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>unique_lock</strong></p>
<p>std::unique_lock要比std::lock_guard功能更多，有更多的成员函数，更灵活,但是更灵活的代价是占用空间相对更大一点且相对更慢一点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mutex myMutex;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; dataOutUnique(myMutex);	// unique_lock&lt;mutex&gt;创建对象，参数为锁对象</span><br><span class="line">	...</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>死锁产生原因及防止方法</strong></p>
<p>当两个线程同时拿着两把及以上的相同的锁时，上锁的顺序必须要一致，否则会发生死锁。</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
            <category> 多线程 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C++面向对象]]></title>
      <url>/c-mian-xiang-dui-xiang.html</url>
      <content type="html"><![CDATA[<h1 id="Object-Oriented"><a href="#Object-Oriented" class="headerlink" title="Object Oriented"></a>Object Oriented</h1><h2 id="Header-头文件-布局"><a href="#Header-头文件-布局" class="headerlink" title="Header(头文件)布局"></a>Header(头文件)布局</h2><pre class="line-numbers language-c++"><code class="language-c++">#ifndef __COMPLEX__
#define __COMPLEX__

#include <cmath>

class ostream;          // forward declarations
class complex;            // 前置声明

complex&
__doapl (complex* ths, const complex& r);

class complex            // class declarations
&#123;                        // 类-声明
...
&#125;;
complex::function ...    // class definition
                        // 类-定义

#endif
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数不能带返回值，函数名必须与类名一致，可以列表初始化：</p>
<pre class="line-numbers language-c++"><code class="language-c++">class complex
&#123;
public:
complex (double r = 0, double i = 0)
: re (r), im (i)                        // initialization list
&#123; &#125;
    
// assignments 赋值
 complex (double r = 0, double i = 0)
&#123; re = r; im = i; &#125;

complex& operator += (const complex&);
double real () const &#123; return re; &#125;
double imag () const &#123; return im; &#125;
private:
double re, im;
friend complex& __doapl (complex*, const complex&); 
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">// 以下两种创建对象方式没有区别
complex c1
complex c2()
// 因此，不能出现以下方式的两种构造函数，会发生歧义    
complex (double r = 0, double i = 0)
: re (r), im (i) 
&#123; &#125;
complex () : re(0), im(0) &#123; &#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><pre class="line-numbers language-c++"><code class="language-c++">double real () const &#123; return re; &#125;
// const 放在这个位置表示他不会改变&#123;&#125;中引进来的数据，也就是不会改变对象中的数据re.(如果你真的不会改变对象中的数据，那你最好一定要加const,防止外部调用时出错)
// eg. 如果real()声明时没加const，下面就会报错
const complex c1(1,3);
cout << c1.real();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="pass-by-reference-amp-return-by-reference"><a href="#pass-by-reference-amp-return-by-reference" class="headerlink" title="pass by reference &amp; return by reference"></a>pass by reference &amp; return by reference</h2><p>传递参数尽量都传递引用，如果不想改变该参数，就加<code>const</code>修饰。</p>
<p>返回值也尽量传递引用（如果可以的话）。</p>
<p><strong>参数传递和返回其实相当于赋值（也即复制），以什么方式递出去，以什么方式接收是各自的事情。</strong></p>
<p><code>return  xx</code>  和实参相当于是传递者，返回值 和形参相当于是接收者<strong>即赋值操作：</strong>（  接收 &#x3D;  传递）</p>
<ul>
<li><p>函数的返回值用于初始化在调用函数时创建的临时对象(temporary object)，如果返回类型不是引用，在调用函数的地方会将函数返回值复制给临时对象。</p>
</li>
<li><p>当函数返回非引用类型时，其返回值既可以是局部对象</p>
</li>
<li><p>千万不要返回局部对象的引用！千万不要返回指向局部对象的指针！</p>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">int& abc(int a, int& result)        // result接收的是该参数的引用。

&#123;
     result = a;
     return result;                    // 返回的是值，单以引用方式接收
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="操作符重载（操作符也相当于是函数）"><a href="#操作符重载（操作符也相当于是函数）" class="headerlink" title="操作符重载（操作符也相当于是函数）"></a>操作符重载（操作符也相当于是函数）</h2><p> 所有的成员函数隐藏了一个<code>this</code>参数（即对象的地址指针），在声明函数的时候<strong>不能</strong>显式声明，但可以显式调用</p>
<h1 id="Object-Based"><a href="#Object-Based" class="headerlink" title="Object  Based"></a>Object  Based</h1><h2 id="Big-Three-三个特殊函数（class-with-pointer-members-必须有copy-ctor-和-copy-op"><a href="#Big-Three-三个特殊函数（class-with-pointer-members-必须有copy-ctor-和-copy-op" class="headerlink" title="Big Three 三个特殊函数（class with pointer members 必须有copy ctor 和 copy op  )"></a>Big Three 三个特殊函数（class with pointer members 必须有copy ctor 和 copy op  )</h2><pre class="line-numbers language-c++"><code class="language-c++">class String
&#123;
public:
String(const char* cstr = 0); 
String(const String& str);                 // 1. 拷贝构造函数，参数为相同对象
String& operator=(const String& str);     // 2. 拷贝赋值函数，参数为相同对象
~String();                          // 3. 析构函数，当对象死亡时自动调用它，并不是它让对象死亡
char* get_c_str() const &#123; return m_data; &#125;
private:
char* m_data;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++"><code class="language-c++">Complex* pc = new Complex(1,2);
...
delete pc;
// 编译器转化为：
//Complex::~Complex(pc); // 析构函数
//operator delete(pc); // 释放内存，其内部调用 free(pc)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
            <category> 面向对象 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C++关键字]]></title>
      <url>/c-guan-jian-zi.html</url>
      <content type="html"><![CDATA[<h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p>定义<strong>内联函数</strong>，该关键字是基于定义的。如果只在函数声明时给出inline，则函数不会被认为是内联函数，所以必须在函数定义的地方也加上inline。</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>定义常量成员，包括const数据成员和const成员函数，const数据成员必须也只能通过构造函数的初始化列表进行初始化。<br>const成员函数只能访问类的成员，不能进行修改，如果需要修改，则引入<code>mutable</code>关键字。</p>
<ol>
<li><p>const修饰普通变量（两种写法都类似）：</p>
<pre class="line-numbers language-c++"><code class="language-c++">const TYPE value; 
TYPE const value;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>const修饰指针 </p>
<p>指针本身是常量不可变：<code>(char*) const pContent;</code><br>指针所指向的内容是常量不可变：<code>const (char) *pContent;</code>或<code>(char) const *pContent;</code><br>两者都不可变：<code>const char* const pContent;</code></p>
</li>
<li><p>const修饰函数 </p>
<p>const修饰函数参数是它最广泛的一种用途，它表示在函数体中不能修改参数的值(包括参数本身的值或者参数其中包含的值)</p>
</li>
<li><p>const修饰类对象&#x2F;对象指针&#x2F;对象引用 </p>
<p>const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。</p>
</li>
<li><p>const修饰数据成员 </p>
<p>const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类声明中初始化const数据成员，因为类的对象未被创建时，编译器不知道const 数据成员的值是什么。</p>
</li>
<li><p>const修饰成员函数</p>
<p>const修饰类的成员函数，用const修饰的成员函数不能改变对象的成员变量。一般把const写在成员函数的最后。</p>
</li>
</ol>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>声明静态成员，包括静态数据成员和静态成员函数，它们被类的所有对象共享，静态数据成员在使用前必须初始化，而静态成员函数只能访问静态数据成员，不能访问非静态数据成员，因为该函数不含有this指针。、</p>
<p>写在class内的东西都是声明而不是定义，因此对于静态成员需要在类外面给出其定义。静态成员在初始化时不能加static关键字，因为加了static关键字表明该变量只在当前文件内访问，而类设计时类中的成员变量是可能在其他文件中被访问的，两者相悖，因此这里不能加static关键字。</p>
<p>当静态成员为public时对其的访问可用对象名加.符号进行访问，也可以用类名加：：作用域解析运算符进行访问。</p>
<ol>
<li><p>面向过程的static关键字 </p>
<p>（1）静态全局变量：</p>
</li>
</ol>
<p>全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。</p>
<pre><code>- 1、该变量在全局数据区分配内存；
- 2、未经初始化的静态全局变量会被程序自动初始化为0；
- 3、静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的。其它文件中可以定义相同名字的变量，不会发生冲突。定义全局变量就可以实现变量在文件中的共享。
</code></pre>
<p>   （2）静态局部变量：<br>   在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。<br>   静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次函数调用，直到下次赋新值。<br>   静态局部变量有以下特点：</p>
<ul>
<li>1、该变量在全局数据区分配内存；</li>
<li>2、静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用**不再进行初始化(跳过 <code>static int a = 4;</code>这一句，后面的赋值<code>a = 5</code>照常执行)**；</li>
<li>3、静态局部变量一般在声明处初始化，如果没有显式初始化，程序自动初始化为0；</li>
<li>4、它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束</li>
</ul>
<p>   （3）静态函数：<br>   在函数的返回类型前加上static关键字，函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。其它文件中可以定义相同名字的函数，不会发生冲突。</p>
<ol start="2">
<li>面向对象的static关键字<br>（1）静态数据成员<br>在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。<br>对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。静态函数可以访问类的静态成员变量，且只能访问静态成员变量。调用时可以使用对象名加.符号进行调用，也可以使用类名加：：作用于解析运算符进行调用。因此静态函数中不能使用this指针访问静态成员，因为当使用：：进行<strong>调用静态函数时，此时没有传入this指针，所以它访问的数据都不是自己的，而是类共有的，这个数据只能是类成员变量，即静态数据了。</strong></li>
</ol>
<ul>
<li>1、对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。</li>
<li>2、静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。</li>
<li>3、静态数据成员和普通数据成员一样遵从public,protected,private访问规则。</li>
<li>4、静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象。</li>
<li>5、在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；</li>
<li>6、静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为： <code>＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞</code>（前面不加<code>static</code>,否则就被锁定只能在这个文件使用了，这不是类想要的结果）</li>
<li>7、类的静态数据成员有两种访问形式：<code>＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞</code></li>
<li>8、静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性。</li>
</ul>
<p>（2）静态成员函数<br>与静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。静态成员函数与静态数据成员一样，都是类的内部实现，属于类定义的一部分。<br>普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。下面举个静态成员函数的例子。<br>关于静态成员函数，可以总结为以下几点：</p>
<ul>
<li>1、出现在类体外的函数定义不能指定关键字static；</li>
<li>2、静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；</li>
<li>3、非静态成员函数可以任意地访问静态成员函数和静态数据成员；</li>
<li>4、静态成员函数不能访问非静态成员函数和非静态数据成员；</li>
<li>5、由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；</li>
<li>6、调用静态成员函数，可以用成员访问操作符来调用静态成员函数，也可以直接使用如下格式： <code>＜类名＞::＜静态成员函数名＞（＜参数表＞）</code></li>
</ul>
<h2 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h2><p>声明虚函数，用于实现多态，该关键字是基于声明的。<br>所谓虚函数，虚就虚在“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。<br>由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被称为“虚”函数。只要在基类中已声明为virtual，这里即使不使用virtual关键字，默认也是虚函数。同样，如果还有从子类派生的子类，对应的成员函数也是虚函数。</p>
<ol>
<li><p>虚函数<br>虚函数只能借助于指针或者引用来达到多态的效果<br>通过这些手段，编译器在看到一个虚函数调用的时候，就将会在运行时刻决定调用哪个函数。虚函数必须要被定义。</p>
</li>
<li><p>虚析构函数<br>析构函数也可以是虚的，甚至是纯虚的。当一个类打算被用作其它类的基类时，它的析构函数必须是虚的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生。而直接用继承类的指针去操作继承类的成员，却不会出现这种情况。</p>
</li>
<li><p>纯虚函数<br>如下声明表示一个函数为纯虚函数（纯虚函数也可以有定义）（如果一个类里面有一个或多个纯虚函数，这个类就是抽象类）。纯虚函数用来规范派生类的行为，实际上就是所谓的“接口”。它告诉使用者，我的派生类都会有这个函数。而试图创建一个抽象基类的独立类对象会导致编译时刻错误。<br><code>virtual void foo()=0; // =0标志一个虚函数为纯虚函数</code></p>
</li>
<li><p>构造函数和析构函数中的虚函数调用<br>一个类的虚函数在它自己的构造函数和析构函数中被调用的时候，它们就变成普通函数了。也就是说不能在构造函数和析构函数中让自己“多态”。这是因为派生类对象中构造函数的调用顺序是，先调用基类的构造函数，然后是派生类的构造函数。在基类析构函数中也是如此。</p>
</li>
<li><p>虚函数与纯虚函数的区别</p>
</li>
</ol>
<ul>
<li>虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。</li>
<li>虚函数可以被直接使用（必须被定义），也可以被子类重载以后以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类只有声明而没有定义。</li>
<li>虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。</li>
<li>虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。</li>
<li>定义了纯虚函数的类称为抽象类，抽象类不能被实例化。</li>
</ul>
<h2 id="friend"><a href="#friend" class="headerlink" title="friend"></a>friend</h2><p>声明友元函数和友元类，该关键字也是基于声明的。<br>采用类的机制后实现了数据的隐藏与封装，类的数据成员一般定义为私有成员，成员函数一般定义为公有的，依此提供类与外界间的通信接口。</p>
<ol>
<li>友元函数<br>有时需要定义一些函数，这些函数不是类的一部分（注意友元函数不是类的一部分），但又需要频繁地访问类的数据成员，这时可以将这些函数定义为该类的友元函数。<br>友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend，其格式如下：<br><code>friend 类型 函数名(形式参数);</code></li>
</ol>
<ul>
<li>友元函数的声明可以放在类的私有部分，也可以放在公有部分，它们是没有区别的，都说明是该类的一个友元函数。</li>
<li>一个函数可以是多个类的友元函数，只需要在各个类中分别声明。友元函数的调用与一般函数的调用方式和原理一致。</li>
<li>友元函数并不是类的成员函数，因此在类外定义的时候不能加上<code>class::function name</code></li>
</ul>
<p>2.友元类<br>除了友元函数外，还有友元类，两者统称为友元。友元的作用是提高了程序的运行效率（即减少了类型检查和安全性检查等都需要时间开销），但它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。同友元函数一样，其也需要在类中加上关键字friend声明。<br>友元类的所有成员函数都是类的友元函数，能存取类的私有成员和保护成员。</p>
<ul>
<li>友元关系不能被继承。</li>
<li>友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</li>
<li>友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明。</li>
</ul>
<h2 id="cast"><a href="#cast" class="headerlink" title="*_cast"></a>*_cast</h2><p>显式类型转换，C++延续了C风格的强制类型转换的语法。dynamic_cast是动态的，需要运行时支持；其它都是静态检查，相比C风格的类型转换更加细化，增强了类型安全性。C++支持四种关键字对不同形式的类型转换进行分别处理。使用格式：<br><code>转换关键字&lt;类型&gt;(表达式)</code></p>
<p>1、<code>static_cast</code>和C风格类型转换功能完全相同，它属于在编译时期静态的类型转换。如果把一个double类型转换为整形，形式如下：<br><code>static_cast&lt;int&gt;(0.1);</code><br><code>static_cast</code>功能有所限制，比如不能转化struct类型到int，不能转化指针到double等。另外，它不能在转换中消除const和volatile属性。</p>
<p>运算符 <strong><code>static_cast</code></strong> <strong>可用于将指向基类的指针转换为指向派生类的指针等操作</strong>。 此类转换并非始终安全。</p>
<p>在下面的示例中，因为 <code>D* pd2 = static_cast&lt;D*&gt;(pb);</code> 可能有不在 <code>D</code> 内的字段和方法，所以行 <code>B</code> 不安全。 但是，因为 <code>B* pb2 = static_cast&lt;B*&gt;(pd);</code> 始终包含所有 <code>D</code>，所以行 <code>B</code> 是安全的转换。</p>
<pre class="line-numbers language-c++"><code class="language-c++">// static_cast_Operator.cpp
// compile with: /LD
class B &#123;&#125;;

class D : public B &#123;&#125;;

void f(B* pb, D* pd) &#123;
   D* pd2 = static_cast<D*>(pb);   // Not safe, D can have fields
                                   // and methods that are not in B.

   B* pb2 = static_cast<B*>(pd);   // Safe conversion, D always
                                   // contains all of B.
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>与 <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/dynamic-cast-operator?view=msvc-170">dynamic_cast相反</a>，不会对 的转换进行运行时 检查 <code>pb</code>。 由 <code>pb</code> 指向的对象可能不是 <code>D</code> 类型的对象，在这种情况下使用 <code>*pd2</code> 会是灾难性的。 例如，调用 <code>D</code> 类（而非 <code>B</code> 类）的成员函数可能会导致访问冲突</p>
<p>2、const_cast用于消除引用或者指针的const或者volatile属性。<br><code>const int &amp;ci=100;</code><br><code>int &amp;i=const_cast&lt;int&amp;&gt;(ci);</code><br>通过这种方式，ci引用的内存单元虽然无法通过修改ci改变，但是可以修改i改变内存的值。这里是把const属性消除，这里想多说一点的是把const加上的问题。</p>
<p>3、<code>dynamic_cast</code>一般出现在类到子类或兄弟类的转换，并要求基类有虚函数。而且它能提供转换后的结果和状态，一旦转换失败则返回空指针。如果没有继承关系的转换一般使用<code>static_cast</code>。</p>
<p>4、<code>reinterpret_casts</code>一般用作函数指针的转换，而且使用它的代码可移植性很差，因为无法确定编译器的函数调用方式等。有可能会导致函数调用出错，一般不常用。</p>
<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>explicit关键字只能用于修饰只有一个参数的类构造函数，它的作用是表明该构造函数是显示的，而非隐式的，跟它相对应的另一个关键字是implicit，意思是隐藏的，类构造函数默认情况下即声明为implicit(隐式)。</p>
<p>explicit关键字只对有一个参数的类构造函数有效，如果类构造函数参数大于或等于两个时，是不会产生隐式转换的，所以explicit关键字也就无效了，而除了第一个参数以外的其他参数都有默认值的时候，explicit关键字依然有效。</p>
<p>除非有心利用，隐式转换常常带来程序逻辑的错误，而且这种错误一旦发生是很难察觉的。原则上应该在所有的构造函数前加explicit关键字，当你有心利用隐式转换的时候再去解除explicit，这样可以大大减少错误的发生。</p>
<p>隐式转换的含义：在C++中，如果的构造函数只有一个参数时，那么在编译的时候就会有一个缺省的转换操作：将该构造函数对应数据类型的数据转换为该类对象。也就是说<code>CxString string2 = 10;</code>这段代码，编译器自动将整型转换为CxString类对象，实际上等同于<code>CxString string2(10);</code></p>
<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>extern意为“外来的”，是存储类声明修饰符。其有两个作用：</p>
<ul>
<li>当它与”C”一起连用时，如: <code>extern &quot;C&quot; void fun(int a, int b);</code>则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的，C++的规则在翻译这个函数名时会把fun这个名字变得面目全非，可能是<code>fun@aBc_int_int#%$</code>也可能是别的，这要看编译器的”脾气”了(不同的编译器采用的方法不一样)，主要是因为C++支持函数的重载。</li>
<li>当extern不与”C”在一起修饰变量或函数时，如在头文件中<code>: extern int g_Int;</code>它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块引用其他模块中的定义，记住它是一个声明不是定义，仅仅是暗示这个函数可能在别的源文件里定义，没有其它作用。这样的用处还是有的，就是在程序中取代<code>include “*.h”</code>来声明函数，在一些复杂的项目中，我比较习惯在所有的函数声明前添加extern修饰。</li>
</ul>
<p>1、extern 和 static<br>（1）extern 表明该变量在别的地方已经定义过了，在这里要使用那个变量。<br>（2）static 表示静态的变量，分配内存的时候，存储在静态区，不存储在栈上面。<br>static 作用范围是内部连接的关系, 和extern有点相反。static与extern是一对“水火不容”的家伙，也就是说extern和static不能同时修饰一个变量。</p>
<p>2、extern 和const<br>C++中const修饰的全局常量据有跟static相同的特性，即它们只能作用于本编译模块中，但是const可以与extern连用来声明该常量可以作用于其他编译模块中, 如<code>extern const char g_str[];</code></p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
            <category> 关键字 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[git]]></title>
      <url>/git2.html</url>
      <content type="html"><![CDATA[<h2 id="安装好Git后必须要设置的一步（设置用户名和邮箱）："><a href="#安装好Git后必须要设置的一步（设置用户名和邮箱）：" class="headerlink" title="安装好Git后必须要设置的一步（设置用户名和邮箱）："></a>安装好Git后必须要设置的一步（设置用户名和邮箱）：</h2><pre class="line-numbers language-sh"><code class="language-sh">git config --global user.name hpstu                           # --global为可选项
git config --global user.email 571091694@qq.com
#查看配置
git config --global --list                                  # --global可选
git config --system --list
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><pre class="line-numbers language-sh"><code class="language-sh">#在当前目录新建一个Git代码库
git init
# or
git clone [url]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h2><pre class="line-numbers language-sh"><code class="language-sh"># 查看指定文件状态
git status [filename]
# 查看所有文件状态
git status
# 添加所有文件到暂存区
git add .
# 提交暂存区的内容到本地仓库，-m后面可以跟提交信息
git commit -m "提交的信息"
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="文件-gitignore"><a href="#文件-gitignore" class="headerlink" title="文件.gitignore"></a>文件.gitignore</h2><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等。<br>在主目录下建立”.gitignore”文件，此文件有如下规则：</p>
<ol>
<li># 表示注释</li>
<li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1，string2.…}）代表可选的字符串等。</li>
<li>如果名称的最前面有一个感叹号（！），表示例外规则，将不被忽略。</li>
<li>如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li>
<li>如果名称的最后面是一个路径分隔符（&#x2F;），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li>
</ol>
<h2 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h2><pre class="line-numbers language-sh"><code class="language-sh"># 列出所有本地分支
git branch
# 列出所有远程分支
git branch -r
# 新建一个分支，但依然停留在当前分支
git branch [branch-name]
# 新建一个分支，并切换到该分支
git checkout -b [branch-name]
# 合并指定分支到当前分支
git merge [branch-name]
# 删除分支
git branch -d [branch-name]
# 删除远程分支
git push origin --delete [branch-name]
git branch -dr [remote/branch]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      
        <categories>
            
            <category> git </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[git]]></title>
      <url>/git.html</url>
      <content type="html"><![CDATA[<h1 id="Git-和-GitHub-详解"><a href="#Git-和-GitHub-详解" class="headerlink" title="Git 和 GitHub 详解"></a>Git 和 GitHub 详解</h1><h2 id="（一）Git-基础"><a href="#（一）Git-基础" class="headerlink" title="（一）Git 基础"></a>（一）Git 基础</h2><h3 id="Git-下载和安装"><a href="#Git-下载和安装" class="headerlink" title="Git 下载和安装"></a>Git 下载和安装</h3><ul>
<li>下载地址： <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></li>
<li>使用默认值安装</li>
<li>资源管理器内单击鼠标右键选择 <code>Git Bash Here</code></li>
<li>输入<code>git --version</code> 检查是否安装成功</li>
</ul>
<h3 id="Git-基本工作流程"><a href="#Git-基本工作流程" class="headerlink" title="Git 基本工作流程"></a>Git 基本工作流程</h3><blockquote>
<p>主要涉及到四个关键点：</p>
<ol>
<li>工作区：本地电脑存放项目文件的地方，比如 learnGitProject 文件夹；</li>
<li>暂存区（Index&#x2F;Stage）：在使用 git 管理项目文件的时候，其本地的项目文件会多出一个.git 的文件夹，将这个.git 文件夹称之为版本库。其中.git 文件夹中包含了两个部分，一个是暂存区（Index 或者 Stage）,顾名思义就是暂时存放文件的地方，通常使用 add 命令将工作区的文件添加到暂存区里；</li>
<li>本地仓库：.git 文件夹里还包括 git 自动创建的 master 分支，并且将 HEAD 指针指向 master 分支。使用 commit 命令可以将暂存区中的文件添加到本地仓库中；</li>
<li>远程仓库：不是在本地仓库中，项目代码在远程 git 服务器上，比如项目放在 github 上，就是一个远程仓库，通常使用 clone 命令将远程仓库拷贝到本地仓库中，开发后推送到远程仓库中即可；</li>
</ol>
<p>因此，经过这样的分析，git 命令可以分为这样的逻辑进行理解和记忆：</p>
<ol>
<li><p>git 管理配置的命令；</p>
<p><strong>几个核心存储区的交互命令：</strong></p>
</li>
<li><p>工作区与暂存区的交互；</p>
</li>
<li><p>暂存区与本地仓库（分支）上的交互；</p>
</li>
<li><p>本地仓库与远程仓库的交互。</p>
</li>
</ol>
<p>作者：你听___<br>链接：<a href="https://juejin.im/post/5ae072906fb9a07a9e4ce596">https://juejin.im/post/5ae072906fb9a07a9e4ce596</a><br>来源：掘金</p>
</blockquote>
<table>
<thead>
<tr>
<th>工作目录</th>
<th>暂存区</th>
<th>git 仓库</th>
<th>远程仓库</th>
</tr>
</thead>
<tbody><tr>
<td>被 Git 管理的项目</td>
<td>临时存放被修改的文件</td>
<td>目录用于存放提交记录</td>
<td>远程代码仓库</td>
</tr>
<tr>
<td><code>git init</code></td>
<td><code>git add</code></td>
<td><code>git commit</code></td>
<td><code>git push</code></td>
</tr>
</tbody></table>
<h3 id="Git-使用前的配置命令"><a href="#Git-使用前的配置命令" class="headerlink" title="Git 使用前的配置命令"></a>Git 使用前的配置命令</h3><p>在使用前告诉 git 你是谁：</p>
<ol>
<li><p>第一次使用 git，配置用户信息</p>
<ol>
<li>配置用户名：<code>git config --global user.name &quot;your name&quot;</code>;</li>
<li>配置用户邮箱：<code>git config --global user.email &quot;youremail@github.com&quot;</code>;</li>
</ol>
</li>
<li><blockquote>
<p>查询配置信息</p>
</blockquote>
<ol>
<li>列出当前配置：<code>git config --list</code>;</li>
<li>列出 repository 配置：<code>git config --local --list</code>;</li>
<li>列出全局配置：<code>git config --global --list</code>;</li>
<li>列出系统配置：<code>git config --system --list</code>;</li>
</ol>
</li>
<li><blockquote>
<p>其他配置</p>
</blockquote>
<ol>
<li>配置解决冲突时使用哪种差异分析工具，比如要使用 vimdiff：<code>git config --global merge.tool vimdiff</code>;</li>
<li>配置 git 命令输出为彩色的：<code>git config --global color.ui auto</code>;</li>
<li>配置 git 使用的文本编辑器：<code>git config --global core.editor vi</code>;</li>
</ol>
</li>
<li><blockquote>
<p>注：</p>
</blockquote>
<ol>
<li>更改–&gt;重复上述命令</li>
<li>也可直接修改 <code>C:\Users\用户\.gitconfig</code></li>
</ol>
</li>
</ol>
<h3 id="工作区上的操作命令"><a href="#工作区上的操作命令" class="headerlink" title="工作区上的操作命令"></a>工作区上的操作命令</h3><h4 id="提交步骤"><a href="#提交步骤" class="headerlink" title="提交步骤"></a>提交步骤</h4><ol>
<li><p><code>git init</code> 初始化 git 仓库</p>
<blockquote>
<blockquote>
<p>新建仓库</p>
</blockquote>
<ol>
<li>将工作区中的项目文件使用 git 进行管理，即创建一个新的本地仓库：<code>git init</code>；</li>
<li>从远程 git 仓库复制项目：<code>git clone </code>; 克隆项目时如果想定义新的项目名，可以在 clone 命令后指定新的项目名：<code>git clone git://github.com/wasd/example.git NewName</code>；</li>
</ol>
</blockquote>
</li>
<li><p><code>git status</code> 查看文件状态</p>
<blockquote>
<blockquote>
<p>查新信息</p>
</blockquote>
<ol>
<li>查询当前工作区所有文件的状态：<code>git status</code>;</li>
<li>比较工作区中当前文件和暂存区之间的差异，也就是修改之后还没有暂存的内容：git diff；指定文件在工作区和暂存区上差异比较：<code>git diff </code>;</li>
</ol>
</blockquote>
</li>
<li><p><code>git add 文件/文件列表</code> 提交到暂存区</p>
<blockquote>
<blockquote>
<p>提交</p>
</blockquote>
<ol>
<li>提交工作区所有文件到暂存区：<code>git add .</code></li>
<li>提交工作区中指定文件到暂存区：<code>git add ...</code>;</li>
<li>提交工作区中某个文件夹中所有文件到暂存区：<code>git add [dir]</code>;</li>
</ol>
</blockquote>
</li>
<li><p><code>git commit -m 提交信息</code> 向仓库提交代码</p>
<blockquote>
<blockquote>
<p>提交文件到版本库</p>
</blockquote>
<ol>
<li>将暂存区中的文件提交到本地仓库中，即打上新版本：<code>git commit -m &quot;commit_info&quot;</code>;</li>
<li>将所有已经使用 git 管理过的文件暂存后一并提交，跳过 add 到暂存区的过程：<code>git commit -a -m &quot;commit_info&quot;</code>;</li>
<li>提交文件时，发现漏掉几个文件，或者注释写错了，可以撤销上一次提交：<code>git commit --amend</code>;</li>
</ol>
</blockquote>
</li>
<li><p><code>git log</code> 查看提交记录</p>
<blockquote>
<blockquote>
<p>查看信息</p>
</blockquote>
<ol>
<li>比较暂存区与上一版本的差异：<code>git diff --cached</code>;</li>
<li>指定文件在暂存区和本地仓库的不同：<code>git diff --cached</code>;</li>
<li>查看提交历史：git log；参数<code>-p</code>展开每次提交的内容差异，用<code>-2</code>显示最近的两次更新，如<code>git log -p -2</code>;</li>
</ol>
</blockquote>
</li>
</ol>
<h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><ul>
<li><p>用暂存区中的文件覆盖工作目录中的文件：<code>git checkout -- 文件名</code> 不加 <code>-- 文件名</code>则覆盖全部文件</p>
</li>
<li><p>将文件从暂存区中删除：<code>git rm --cached 文件名</code></p>
</li>
<li><p>将 git 仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录：<code> git reset --hard commitID</code></p>
</li>
<li><blockquote>
<blockquote>
<p>撤销</p>
</blockquote>
<ol>
<li>删除工作区文件，并且也从暂存区删除对应文件的记录：<code>git rm </code>;</li>
<li>从暂存区中删除文件，但是工作区依然还有该文件:<code>git rm --cached </code>;</li>
<li>取消暂存区已经暂存的文件：<code>git reset HEAD ...</code>;</li>
<li>撤销上一次对文件的操作：<code>git checkout --</code>。要确定上一次对文件的修改不再需要，如果想保留上一次的修改以备以后继续工作，可以使用 stashing 和分支来处理；</li>
<li>隐藏当前变更，以便能够切换分支：<code>git stash</code>；</li>
<li>查看当前所有的储藏：<code>git stash list</code>；</li>
<li>应用最新的储藏：<code>git stash apply</code>，如果想应用更早的储藏：<code>git stash apply stash@&#123;2&#125;</code>；重新应用被暂存的变更，需要加上<code>--index</code>参数：<code>git stash apply --index</code>;</li>
<li>使用 apply 命令只是应用储藏，而内容仍然还在栈上，需要移除指定的储藏：<code>git stash drop stash&#123;0&#125;</code>；如果使用 pop 命令不仅可以重新应用储藏，还可以立刻从堆栈中清除：<code>git stash pop</code>;</li>
<li>在某些情况下，你可能想应用储藏的修改，在进行了一些其他的修改后，又要取消之前所应用储藏的修改。Git 没有提供类似于 stash unapply 的命令，但是可以通过取消该储藏的补丁达到同样的效果：<code>git stash show -p stash@&#123;0&#125; | git apply -R</code>；同样的，如果你沒有指定具体的某个储藏，Git 会选择最近的储藏：<code>git stash show -p | git apply -R</code>；</li>
</ol>
<blockquote>
<p>更新文件</p>
</blockquote>
<ol>
<li>重命名文件，并将已改名文件提交到暂存区：<code>git mv [file-original] [file-renamed]</code>;</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="（二）Git-进阶"><a href="#（二）Git-进阶" class="headerlink" title="（二）Git 进阶"></a>（二）Git 进阶</h2><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>生成副本，避免影响开发主线</p>
<h4 id="分支细分"><a href="#分支细分" class="headerlink" title="分支细分"></a>分支细分</h4><ol>
<li>主分支（master）：第一次向 git 仓库提交更新记录时自动产生的一个分支。</li>
<li>开发分支（develop）：作为开发的分支，基于 master 分支创建。</li>
<li>功能分支（feature）：作为开发具体功能的分支基于开发分支创建。</li>
</ol>
<h4 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h4><ul>
<li><code>git branch</code> 查看分支</li>
<li><code>git branch 分支名称</code> 创建分支</li>
<li><code>git checkout 分支名称</code> 切换分支</li>
<li><code>git merge 来源分支</code> 合并分支</li>
<li><code>git branch -d 分支名称</code> 删除分支（分支合并后才允许被删除）（-D 大写强制删除）<ul>
<li><code>git push origin :branch-name</code> : 远程仓库同步删除掉的分支</li>
</ul>
</li>
</ul>
<p>注意：</p>
<p> 开发分支文件后要 <code>commit</code> 后再切换主分支，否则分支文件会出现在主分支里面。</p>
<blockquote>
<blockquote>
<p>分支管理</p>
</blockquote>
<ol>
<li>创建分支：<code>git branch </code>，如<code>git branch testing</code>；</li>
<li>从当前所处的分支切换到其他分支：<code>git checkout </code>，如<code>git checkout testing</code>；</li>
<li>新建并切换到新建分支上：<code>git checkout -b </code>;</li>
<li>删除分支：<code>git branch -d </code>；</li>
<li>将当前分支与指定分支进行合并：<code>git merge </code>;</li>
<li>显示本地仓库的所有分支：<code>git branch</code>;</li>
<li>查看各个分支最后一个提交对象的信息：<code>git branch -v</code>;</li>
<li>查看哪些分支已经合并到当前分支：<code>git branch --merged</code>;</li>
<li>查看当前哪些分支还没有合并到当前分支：<code>git branch --no-merged</code>;</li>
<li>把远程分支合并到当前分支：<code>git merge /</code>，如<code>git merge origin/serverfix</code>；如果是单线的历史分支不存在任何需要解决的分歧，只是简单的将 HEAD 指针前移，所以这种合并过程可以称为快进（Fast forward），而如果是历史分支是分叉的，会以当前分叉的两个分支作为两个祖先，创建新的提交对象；如果在合并分支时，遇到合并冲突需要人工解决后，再才能提交；</li>
<li>在远程分支的基础上创建新的本地分支<code>：git checkout -b /</code>，如<code>git checkout -b serverfix origin/serverfix</code>;</li>
<li>从远程分支 checkout 出来的本地分支，称之为跟踪分支。在跟踪分支上向远程分支上推送内容：<code>git push</code>。该命令会自动判断应该向远程仓库中的哪个分支推送数据；在跟踪分支上合并远程分支：<code>git pull</code>；</li>
<li>将一个分支里提交的改变移到基底分支上重放一遍：<code>git rebase </code>，如<code>git rebase master server</code>，将特性分支 server 提交的改变在基底分支 master 上重演一遍；使用 rebase 操作最大的好处是像在单个分支上操作的，提交的修改历史也是一根线；如果想把基于一个特性分支上的另一个特性分支变基到其他分支上，可以使用<code>--onto</code>操作：<code>git rebase --onto </code>，如<code>git rebase --onto master server client</code>；使用 rebase 操作应该遵循的原则是：<strong>一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行 rebase 操作</strong>；</li>
</ol>
</blockquote>
<h3 id="暂时保存更改"><a href="#暂时保存更改" class="headerlink" title="暂时保存更改"></a>暂时保存更改</h3><p>git 中可以不提交更改，只提取分支上所有改动并储存，让开发人员得到一个干净的副本，临时转向其它工作。复制到“剪切板”，可以“粘贴“到其它分支。</p>
<p>场景：</p>
<ul>
<li>储存临时改动：<code>git stash</code></li>
<li>恢复临时改动：<code>git stash pop</code></li>
</ul>
<h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><blockquote>
<p>Git 使用的标签有两种类型：<strong>轻量级的（lightweight）和含附注的（annotated）</strong>。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。</p>
<ol>
<li>列出现在所有的标签：<code>git tag</code>;</li>
<li>使用特定的搜索模式列出符合条件的标签，例如只对 1.4.2 系列的版本感兴趣：<code>git tag -l &quot;v1.4.2.*&quot;</code>;</li>
<li>创建一个含附注类型的标签，需要加<code>-a</code>参数，如<code>git tag -a v1.4 -m &quot;my version 1.4&quot;</code>;</li>
<li>使用 git show 命令查看相应标签的版本信息，并连同显示打标签时的提交对象：<code>git show v1.4</code>;</li>
<li>如果有自己的私钥，可以使用 GPG 来签署标签，只需要在命令中使用<code>-s</code>参数：<code>git tag -s v1.5 -m &quot;my signed 1.5 tag&quot;</code>;</li>
<li>验证已签署的标签：git tag -v ，如<code>git tag -v v1.5</code>;</li>
<li>创建一个轻量级标签的话，就直接使用 git tag 命令即可，连<code>-a</code>,<code>-s</code>以及<code>-m</code>选项都不需要，直接给出标签名字即可，如<code>git tag v1.5</code>;</li>
<li>将标签推送到远程仓库中：git push origin ，如<code>git push origin v1.5</code>；</li>
<li>将本地所有的标签全部推送到远程仓库中：<code>git push origin --tags</code>;</li>
</ol>
</blockquote>
<h2 id="（三）Github"><a href="#（三）Github" class="headerlink" title="（三）Github"></a>（三）Github</h2><h3 id="注册-Github-账号"><a href="#注册-Github-账号" class="headerlink" title="注册 Github 账号"></a>注册 Github 账号</h3><p>略~</p>
<h3 id="多人协作开发流程"><a href="#多人协作开发流程" class="headerlink" title="多人协作开发流程"></a>多人协作开发流程</h3><ul>
<li>A 在自己的计算机中创建本地仓库</li>
<li>A 在 GitHub 中创建远程仓库</li>
<li>A 将本地仓库推送到远程仓库</li>
<li>B 克隆远程仓库到本地进行开发</li>
<li>B 将本地仓库开发内容推送到远程仓库</li>
<li>A 将远程仓库中的最新内容拉去本地</li>
</ul>
<h3 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h3><p><img src="/git_notes/20191115154237.png"></p>
<h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><ol>
<li><p><code>git push 远程仓库地址 分支名称</code></p>
</li>
<li><p><code>git push 远程仓库地址别名 分支名称</code></p>
</li>
<li><p><code>git push -u 远程仓库地址别名 分支名称</code></p>
<p><code>-u</code> 记住推送地址和分支，下次只需要输入<code>git push</code></p>
</li>
<li><p><code>git remote add 远程仓库地址别名 远程仓库地址</code></p>
</li>
<li><p>删除别名：<code>git remote remove 远程仓库地址别名</code></p>
</li>
<li><p>第一次提交需要用户名和密码，电脑会记住密码在凭据管理器，第二次就不用了。</p>
</li>
<li><blockquote>
<h3 id="本地仓库上的操作"><a href="#本地仓库上的操作" class="headerlink" title="本地仓库上的操作"></a>本地仓库上的操作</h3><ol>
<li>查看本地仓库关联的远程仓库：<code>git remote</code>；在克隆完每个远程仓库后，远程仓库默认为<code>origin</code>;加上<code>-v</code>的参数后，会显示远程仓库的<code>url</code>地址；</li>
<li>添加远程仓库，一般会取一个简短的别名：<code>git remote add [remote-name] [url]</code>，比如：<code>git remote add example git://github.com/example/example.git</code>;</li>
<li>从远程仓库中抓取本地仓库中没有的更新：<code>git fetch [remote-name]</code>，如<code>git fetch origin</code>;使用 fetch 只是将远端数据拉到本地仓库，并不自动合并到当前工作分支，只能人工合并。如果设置了某个分支关联到远程仓库的某个分支的话，可以使用<code>git pull</code>来拉去远程分支的数据，然后将远端分支自动合并到本地仓库中的当前分支；</li>
<li>将本地仓库某分支推送到远程仓库上：<code>git push [remote-name] [branch-name]</code>，如<code>git push origin master</code>；如果想将本地分支推送到远程仓库的不同名分支：<code>git push :</code>，如<code>git push origin serverfix:awesomebranch</code>;如果想删除远程分支：<code>git push [romote-name] :</code>，如<code>git push origin :serverfix</code>。这里省略了本地分支，也就相当于将空白内容推送给远程分支，就等于删掉了远程分支。</li>
<li>查看远程仓库的详细信息：<code>git remote show origin</code>；</li>
<li>修改某个远程仓库在本地的简称：<code>git remote rename [old-name] [new-name]</code>，如<code>git remote rename origin org</code>；</li>
<li>移除远程仓库：<code>git remote rm [remote-name]</code>；</li>
</ol>
</blockquote>
</li>
</ol>
<h3 id="拉取仓库"><a href="#拉取仓库" class="headerlink" title="拉取仓库"></a>拉取仓库</h3><h4 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h4><ul>
<li>克隆远程仓库到本地：<code>git clone 仓库地址</code></li>
</ul>
<h4 id="拉取远程仓库中最新版本"><a href="#拉取远程仓库中最新版本" class="headerlink" title="拉取远程仓库中最新版本"></a>拉取远程仓库中最新版本</h4><ul>
<li>拉取远程仓库最新版本到本地：<code> git pull 远程仓库地址 分支名称</code></li>
</ul>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>多人开发同一个项目时，如果两个人修改了同一个文件同一个地方</p>
<ol>
<li><code> git pull</code></li>
<li>手动解决冲突</li>
<li><code> git push</code></li>
</ol>
<p><img src="/git_notes/20191115164339.png"></p>
<h3 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h3><ol>
<li><code> fork</code>到自己的远程仓库</li>
<li><code> clone</code>到本地进行修改</li>
<li><code> push</code>到远程仓库</li>
<li><code> pull request</code>发送给原作者</li>
<li>原作者查看<code>commit</code> 审核</li>
<li>原作者 <code> merge pull request</code></li>
</ol>
<h3 id="SSH-免密登录"><a href="#SSH-免密登录" class="headerlink" title="SSH 免密登录"></a>SSH 免密登录</h3><ol>
<li><p>生成密钥：<code> ssh-keygen</code></p>
<p>密匙储存目录：<code> C:\User\用户\.ssh</code></p>
<p>公钥名称：<code> id_rsa.pub</code></p>
<p>私钥名称：<code> id_rsa</code></p>
</li>
<li><p>Github 添加公钥</p>
</li>
</ol>
<p><img src="/git_notes/20191115165957.png"></p>
<ol start="3">
<li><p>复制 SSH 地址：</p>
<p><img src="/git_notes/20191115170348.png"></p>
</li>
<li><p>设置 ssh 别名：<code>$ git remote add origin_ssh SSH地址 </code></p>
</li>
<li><p>远程推送：<code> $ git push origin_ssh master</code></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000013154540">ubuntu git 环境搭建以及通过 SSH 连接 Github（免密码）配置</a></p>
</li>
</ol>
<h3 id="Git-忽略清单"><a href="#Git-忽略清单" class="headerlink" title="Git 忽略清单"></a>Git 忽略清单</h3><p>将不需要的文件名字添加到此文件中，执行 git 命令时就会忽略这些文件。</p>
<ul>
<li><p>git 忽略清单文件名称：<code>.gitignore</code></p>
</li>
<li><p>将工作目录所有文件添加到缓存区：<code> git add .</code></p>
</li>
<li><p>例子：</p>
<pre class="line-numbers language-gitignore"><code class="language-gitignore"># 此为注释 – 将被 Git 忽略
# 忽略所有 .a 结尾的文件
*.a
# 但 lib.a 除外
!lib.a
# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
/TODO
# 忽略 build/ 目录下的所有文件
build/
# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
doc/*.txt
# 忽略 doc/ 目录下所有扩展名为 txt 的文件
doc/**/*.txt
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="为仓库添加说明"><a href="#为仓库添加说明" class="headerlink" title="为仓库添加说明"></a>为仓库添加说明</h3><p>在仓库根目录添加<code>readme.md</code>文件即可</p>
<h2 id="（四）使用-SourceTree-管理-Git"><a href="#（四）使用-SourceTree-管理-Git" class="headerlink" title="（四）使用 SourceTree 管理 Git"></a>（四）使用 SourceTree 管理 Git</h2><blockquote>
<p><a href="https://blog.csdn.net/u012230055/article/details/64125268">https://blog.csdn.net/u012230055/article/details/64125268</a></p>
</blockquote>
<h3 id="一-、SourceTree-简介"><a href="#一-、SourceTree-简介" class="headerlink" title="一 、SourceTree 简介"></a>一 、SourceTree 简介</h3><p>SourceTree 是 Windows 和 Mac OS X 下免费的 <a href="http://lib.csdn.net/base/git">Git</a> 和 Hg 客户端，拥有可视化界面，容易上手操作。同时它也是 Mercurial 和 Subversion<a href="http://lib.csdn.net/base/git">版本控制</a>系统工具。支持创建、提交、clone、push、pull 和 merge 等操作。</p>
<h3 id="二、下载安装-SourceTree-步骤"><a href="#二、下载安装-SourceTree-步骤" class="headerlink" title="二、下载安装 SourceTree 步骤"></a>二、下载安装 SourceTree 步骤</h3><ol>
<li><p>下载地址：<a href="https://www.sourcetreeapp.com/%EF%BC%8C%E8%AF%A5%E7%89%88%E6%9C%AC%E6%98%AF%E4%B8%AD%E6%96%87%E7%9A%84%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85%E3%80%82">https://www.sourcetreeapp.com/，该版本是中文的，下载完成后可以进行安装。</a></p>
</li>
<li><p>点击“install”，安装完成后，打开 sourcetree，点击“user an existing account”</p>
</li>
<li><p>注意：使用谷歌帐号登录即可，前提是你必须可以上谷歌才可以。</p>
</li>
<li><p>直接点击“跳过初始设置”即可。</p>
</li>
<li><p>登录注册成功后，弹出设置 puttykey 的界面，点击“取消”即可。</p>
</li>
<li><p>点击“取消”按钮，弹出如下提示框：<br><img src="https://img-blog.csdn.net/20170320145556338?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>此时进入到 sourcetree 的主界面，现在就可以使用 sourcetree 啦。</p>
</li>
</ol>
<h3 id="三、集成文件对比插件"><a href="#三、集成文件对比插件" class="headerlink" title="三、集成文件对比插件"></a>三、集成文件对比插件</h3><p>安装对比插件</p>
<p>Sourcetree 中集成 Beyond Compare 4，当文件冲突时可以很好的解决冲突。安装过程很简单，这里不再详述。</p>
<p>Sourcetree 中配置 Beyond Compare 4</p>
<p>菜单栏，“工具”——“选项”，如图所示：<br><img src="https://img-blog.csdn.net/20170320145615677?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>选择“比较”选项卡，然后将红色方框处的内容修改为如图所示：<br><img src="https://img-blog.csdn.net/20170320145628604?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="四、SourceTree-基本使用"><a href="#四、SourceTree-基本使用" class="headerlink" title="四、SourceTree 基本使用"></a>四、SourceTree 基本使用</h3><h4 id="（1）克隆"><a href="#（1）克隆" class="headerlink" title="（1）克隆"></a>（1）克隆</h4><p>点击克隆按钮，克隆项目：<br>既可以是本地已有的 git 项目，也可以是远程目录中的项目，<br><img src="https://img-blog.csdn.net/20170320145642692?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p> 本地存在的 git 项目，<br> 获取项目克隆地址，点击克隆按钮，如图所示：<br><img src="https://img-blog.csdn.net/20170320145732677?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p> 1、克隆项目的路径<br> 2、克隆项目存放的位置<br> 3、如果要下载特定的分支，可以按分支进行下载</p>
<h4 id="（2）配置忽略文件"><a href="#（2）配置忽略文件" class="headerlink" title="（2）配置忽略文件"></a>（2）配置忽略文件</h4><p> 利用.gitignore 过滤文件，如编译过程中的中间文件，等等，这些文件不需要被追踪管理。<br> .gitignore 文件只对还没有加入版本管理的文件起作用，如果之前已经用 git 把这些文件纳入了版本库，就不起作用了<br> 使用 sourcetree 添加忽略文件的方法：<br> 正常情况下，管理员创建项目后需要直接将忽略文件创建好。创建方法如图：<br><img src="https://img-blog.csdn.net/20170320150016000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>按照如上步骤操作即可编辑冲突文件。<br>冲突文件规则：<br>忽略文件夹（如：bin、obj）：<br>obj&#x2F;<br>bin&#x2F;<br>某目录下的所有.txt 文件，<br>obj&#x2F;*.txt<br>开发的过程中可能遇到一些忽略文件中未添加的文件，此时需要开发者自行添加忽略文件，添加方法如下：<br>之前已经介绍过未进行版本控制的或者受版本控制的文件，在 sourcetree 的“文件状态” 标签中查找，如图所示：<br><img src="https://img-blog.csdn.net/20170320150046235?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>鼠标右键要忽略的文件，点击“忽略”，选择忽略的模式，即可将文件进行忽略，如图所示：<br><img src="https://img-blog.csdn.net/20170320150104001?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="（3）tag-使用方法"><a href="#（3）tag-使用方法" class="headerlink" title="（3）tag 使用方法"></a>（3）tag 使用方法</h4><p> 打 tag 的目的是在代码的主要节点处有个标记，方便下次修改代码时可以准确的找到想要找的代码。而无需看着日志文件逐一回忆要找的代码位置。<br><img src="https://img-blog.csdn.net/20170320150324493?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="（4）分支管理与使用"><a href="#（4）分支管理与使用" class="headerlink" title="（4）分支管理与使用"></a>（4）分支管理与使用</h4><p> 使用 sourcetree 创建和使用分支是很方便的，不像之前使用的 TortoiseGit 只能在当前代码处创建分支，使用 sourcetree 的方便之处：<br> 1、可以选择特定的某版本创建分支<br> 2、代码检出时可以按照分支进行检出<br> 3、分支的添加很简单<br>分支添加：<br><img src="https://img-blog.csdn.net/20170320150335144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p> 1、可以在当前的版本下创建分支<br> 2、选择指定的提交创建分支<br> 3、点击“创建分支”<br>分支提交到服务器：<br> 在 sourcetree 右侧内容中的分支列表中，选中创建的分支，右键提交，如图所示：<br><img src="https://img-blog.csdn.net/20170320150351024?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>分支合并：<br>1、分支合并功能和分支添加功能类似，这里不再详述，需要注意的是首先要切换到被合并的分支上，再进行合并操作。<br>2、分支合并时，可以选择具体的某提交进行合并，同时主分支可以合并到子分支；子分支可以合并到主分支；子分支之间也可以进行合并。</p>
<h4 id="（5）GIT-与-SVN-同步"><a href="#（5）GIT-与-SVN-同步" class="headerlink" title="（5）GIT 与 SVN 同步"></a>（5）GIT 与 SVN 同步</h4><p> git svn 工具集在当前不得不使用 Subversion 服务器或者开发环境要求使用 Subversion 服务器的时候格外有用。不妨把它看成一个跛脚的 Git，在实际使用中不推荐这样使用 GIT。</p>
<h4 id="（6）基本步骤"><a href="#（6）基本步骤" class="headerlink" title="（6）基本步骤"></a>（6）基本步骤</h4><p>提交、拉取和推送<br>提交：<br>项目提交是为了维护本地版本库，如果本地有未提交的内容，则不允许拉取和推送；如图所示区域有内容时，则代表本地未提交的内容：<br><img src="https://img-blog.csdn.net/20170320150734479?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p> 点击 Stage All，填写提交信息既可以将本地内容（暂存区）提交到本地版本库，如图所示：<br><img src="https://img-blog.csdn.net/20170320150743869?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p> 1、将未暂存的文件进行暂存，如果有些文件不需要暂存，则可以进行删除，选中文件，右键“移除”即可。<br> 拉取：从远程将代码进行更新，相当于 SVN 的“更新”<br> 推送：将代码提交到远程。</p>
<h4 id="（7）解决冲突"><a href="#（7）解决冲突" class="headerlink" title="（7）解决冲突"></a>（7）解决冲突</h4><p> 简单介绍<br><img src="https://img-blog.csdn.net/20170320150800182?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p> 1、冲突文件的符号为“感叹号”<br> 2、选中“冲突文件”，右键——点击”解决冲突“——点击”打开外部合并工具“（备注：才操作时已经安装外部合并工具，同时在 sourcetree 中已经进行配置，详见”集成文件对比插件“）</p>
<p> 冲突界面</p>
<p> 冲突解决界面如下：可以根据需要选择内容显示类型，只”显示更改“，”显示冲突“或者”全部“<br><img src="https://img-blog.csdn.net/20170320150910886?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p> 解决冲突</p>
<p> 方法一：在相关的版本处，选中”冲突行”，合并区默认处于合并位置，鼠标右键，选择最终冲突地方留下的内容，如图：<br><img src="https://img-blog.csdn.net/20170320151133515?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p> 解决冲突之后效果图：<br><img src="https://img-blog.csdn.net/20170320151150544?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p> 1、冲突图标由”感叹号”——“省略号”。<br> 2、右侧显示修改后的代码进行查看。<br> 3、同时修改的冲突文件有相应的备份，大家可以下载到本地，方便冲突有问题再次修改文件。<br>备注：该文件下载之后请将版本库中的该文件删除，不要上传到版本库中。<br> 4、修改完冲突之后，需要再次提交，推送。大家养成提交时，提交有效的日志信息，不要将比如：123 之类的信息推送到服务器中。<br> 方法二：如果冲突非常少，可以直接在右侧栏中解决冲突，如图所示：<br><img src="https://img-blog.csdn.net/20170320151202374?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p> 1、点击未暂存区域的冲突文件。<br> 2、右侧列表中出现冲突的内容。<br> 3、选择冲突内容，解决冲突，如图所示：<br><img src="https://img-blog.csdn.net/20170320151244766?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p> 暂存行：表示保留该内容<br> 丢弃行：表示删除该内容<br> 备注：区分于第一种方式，使用第一种方法解决时，不要点击”未暂存文件”,否则可能无法打开冲突文件</p>
<h4 id="（8）版本回退"><a href="#（8）版本回退" class="headerlink" title="（8）版本回退"></a>（8）版本回退</h4><p> 原则上，代码推送之前要保证本地的代码可运行，不要将不可运行或者有问题的代码推送到服务器上，如果由于误操作，将代码推送到了远程，想重新修改上传代码，此时，需要将版本进行回退，回 退方法如图：<br><img src="https://img-blog.csdn.net/20170320151400612?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p> 1、切换到日志&#x2F;历史标签<br> 2、选择要恢复到的版本，如图蓝色位置<br> 3、鼠标右键，选择“重置当前分支到此次提交”<br> 4、选择”重置模式”，如图所示<br><img src="https://img-blog.csdn.net/20170320151415795?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p> 5、弹出框中选择”Yes”<br><img src="https://img-blog.csdn.net/20170320151427565?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="（9）相关提示信息含义"><a href="#（9）相关提示信息含义" class="headerlink" title="（9）相关提示信息含义"></a>（9）相关提示信息含义</h4><p> 冲突信息<br><img src="https://img-blog.csdn.net/20170320151439378?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p> 先更新信息<br><img src="https://img-blog.csdn.net/20170320151450207?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br> 小窍门：<br><img src="https://img-blog.csdn.net/20170320151502061?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjIzMDA1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br> 如果推送时，拉取右上方显示数字，则需要先拉取再推送。</p>
<h3 id="五、SourceTree-amp-Git-部分名词解释"><a href="#五、SourceTree-amp-Git-部分名词解释" class="headerlink" title="五、SourceTree&amp;Git 部分名词解释"></a>五、SourceTree&amp;Git 部分名词解释</h3><p>**克隆(clone)**：从远程仓库 URL 加载创建一个与远程仓库一样的本地仓库<br>**提交(commit)**：将暂存文件上传到本地仓库（我们在 Finder 中对本地仓库做修改后一般都得先提交一次，再推送）<br>**检出(checkout)**：切换不同分支<br><strong>添加（add）</strong>：添加文件到缓存区<br><strong>移除（remove）</strong>：移除文件至缓存区<br>**暂存(git stash)**：保存工作现场<br>**重置(reset)**：回到最近添加(add)&#x2F;提交(commit)状态<br>**合并(merge)**：将多个同名文件合并为一个文件，该文件包含多个同名文件的所有内容，相同内容抵消<br>**抓取(fetch)**：从远程仓库获取信息并同步至本地仓库<br>**拉取(pull)**：从远程仓库获取信息并同步至本地仓库，并且自动执行合并（merge）操作，即 pull&#x3D;fetch+merge<br>**推送(push)**：将本地仓库同步至远程仓库，一般推送（push）前先拉取（pull）一次，确保一致<br>**分支(branch)**：创建&#x2F;修改&#x2F;删除分枝<br><strong>标签(tag)</strong>:给项目增添标签<br><strong>工作流(Git Flow)</strong>:团队工作时，每个人创建属于自己的分枝（branch），确定无误后提交到 master 分枝<br><strong>终端(terminal)</strong>:可以输入 git 命令行</p>
<h2 id="Git-设置，查看，取消代理"><a href="#Git-设置，查看，取消代理" class="headerlink" title="Git 设置，查看，取消代理"></a>Git 设置，查看，取消代理</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 设置代理</span>
<span class="token function">git</span> config --global http.proxy <span class="token string">'http://127.0.0.1:7890'</span> <span class="token comment" spellcheck="true"># 这是设置的默认端口 7890</span>
<span class="token function">git</span> config --global https.proxy <span class="token string">'http://127.0.0.1:7890'</span>
<span class="token comment" spellcheck="true"># 查看代理</span>
<span class="token function">git</span> config --global --get http.proxy
<span class="token function">git</span> config --global --get https.proxy
<span class="token comment" spellcheck="true"># 取消代理</span>
<span class="token function">git</span> config --global --unset http.proxy
<span class="token function">git</span> config --global --unset https.proxy
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      
        <categories>
            
            <category> git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[bash]]></title>
      <url>/bash.html</url>
      <content type="html"><![CDATA[<h1 id="bash-执行方式"><a href="#bash-执行方式" class="headerlink" title="bash 执行方式"></a>bash 执行方式</h1><p>脚本执行方式：</p>
<ol>
<li>直接输入文件及其路径（绝对路径或者相对路径）<pre class="line-numbers language-bash"><code class="language-bash">./haha.sh   
/home/hp/桌面/haha.sh
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>也可以将脚本文件作为参数传给Shell程序，使其解释并执行脚本文件的·内容<pre class="line-numbers language-sh"><code class="language-sh">bash ./haha.sh
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>还可以使用source命令执行文件<pre class="line-numbers language-sh"><code class="language-sh">source ./haha.sh
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
如果文件没权限执行则添加权限<pre class="line-numbers language-sh"><code class="language-sh">sudo chmod +x ./haha.sh
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<p><strong>注意变量赋值等号( &#x3D; )之间不能有空格</strong></p>
<pre class="line-numbers language-sh"><code class="language-sh">n=10         #True
n = 10       #False
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Shell是一种弱类型的编程语言。(类似Python)</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>与 Unix 主题“任何东西都是一个文件”保持一致，程序，比方说 ls，实际上把他们的运行<br>结果输送到一个叫做标准输出的特殊文件（经常用 stdout 表示），而它们的状态信息则送到另<br>一个叫做标准错误的文件（stderr）。默认情况下，标准输出和标准错误都连接到屏幕，而不是<br>保存到磁盘文件。除此之外，许多程序从一个叫做标准输入（stdin）的设备得到输入，默认情<br>况下，标准输入连接到键盘。</p>
<p>I&#x2F;O 重定向允许我们更改输出地点和输入来源。一般地，输出送到屏幕，输入来自键盘，但<br>是通过 I&#x2F;O 重定向，我们可以做出改变。</p>
<p>I&#x2F;O 重定向允许我们来重定义标准输出的地点。我们使用 “&gt;” 重定向符后接文件名将标准输<br>出重定向到除屏幕以外的另一个文件。为什么我们要这样做呢？因为有时候把一个命令的运<br>行结果存储到一个文件很有用处。例如，我们可以告诉 shell 把 ls 命令的运行结果输送到文件<br>ls-output.txt 中去，由文件代替屏幕。</p>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">ls</span> -l /usr/bin <span class="token operator">></span> ls-output.txt
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里，我们创建了一个长长的目录&#x2F;usr&#x2F;bin 列表，并且输送程序运行结果到文件 ls-output.txt<br>中。</p>
<p>程序不把它的错误信息输送到标准输出。反而，像许多写得不错的 Unix 程序，ls 把错误信息送到标准错误。</p>
<h2 id="命令的组合符-amp-amp-和"><a href="#命令的组合符-amp-amp-和" class="headerlink" title="命令的组合符&amp;&amp;和||"></a>命令的组合符<code>&amp;&amp;</code>和<code>||</code></h2><p>除了分号，Bash 还提供两个命令组合符<code>&amp;&amp;</code>和<code>||</code>，允许更好地控制多个命令之间的继发关系。</p>
<pre class="line-numbers language-sh"><code class="language-sh">Command1 && Command2
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上面命令的意思是，如果<code>Command1</code>命令运行成功，则继续运行<code>Command2</code>命令。</p>
<pre class="line-numbers language-sh"><code class="language-sh">Command1 || Command2
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上面命令的意思是，如果<code>Command1</code>命令运行失败，则继续运行<code>Command2</code>命令。</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>Bash 提供很多快捷键，可以大大方便操作。下面是一些最常用的快捷键，完整的介绍参见《行操作》一章。</p>
<ul>
<li><code>Ctrl + L</code>：清除屏幕并将当前行移到页面顶部。</li>
<li><code>Ctrl + C</code>：中止当前正在执行的命令。</li>
<li><code>Shift + PageUp</code>：向上滚动。</li>
<li><code>Shift + PageDown</code>：向下滚动。</li>
<li><code>Ctrl + U</code>：从光标位置删除到行首。</li>
<li><code>Ctrl + K</code>：从光标位置删除到行尾。</li>
<li><code>Ctrl + D</code>：关闭 Shell 会话。</li>
<li><code>↑</code>，<code>↓</code>：浏览已执行命令的历史记录</li>
<li>ctrl+A 跳到光标所在行的行首</li>
<li>ctrl+E 跳到光标所在行的行尾</li>
<li>ctrl+W 删除光标前的单个域</li>
</ul>
<h3 id="Bash-只有一种数据类型，就是字符串。不管用户输入什么数据，Bash-都视为字符串。"><a href="#Bash-只有一种数据类型，就是字符串。不管用户输入什么数据，Bash-都视为字符串。" class="headerlink" title="Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。"></a>Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。</h3><h2 id="变量声明的语法如下。"><a href="#变量声明的语法如下。" class="headerlink" title="变量声明的语法如下。"></a>变量声明的语法如下。</h2><pre class="line-numbers language-sh"><code class="language-sh">variable=value
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上面命令中，等号左边是变量名，右边是变量。注意，等号两边不能有空格。</p>
<p>如果变量的值包含空格，则必须将值放在引号中。</p>
<pre class="line-numbers language-sh"><code class="language-sh">myvar="hello world"
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="Shebang-行"><a href="#Shebang-行" class="headerlink" title="Shebang 行"></a>Shebang 行</h2><p>脚本的第一行通常是指定解释器，即这个脚本必须通过什么解释器执行。这一行以<code>#!</code>字符开头，这个字符称为 Shebang，所以这一行就叫做 Shebang 行。</p>
<p><code>#!</code>后面就是脚本解释器的位置，Bash 脚本的解释器一般是<code>/bin/sh</code>或<code>/bin/bash</code>。</p>
<pre class="line-numbers language-sh"><code class="language-sh">#!/bin/sh
# 或者
#!/bin/bash
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>#!</code>与脚本解释器之间有没有空格，都是可以的。</p>
<p>如果 Bash 解释器不放在目录<code>/bin</code>，脚本就无法执行了。为了保险，可以写成下面这样。</p>
<pre class="line-numbers language-sh"><code class="language-sh">#!/usr/bin/env bash
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上面命令使用<code>env</code>命令（这个命令总是在<code>/usr/bin</code>目录），返回 Bash 可执行文件的位置。<code>env</code>命令的详细介绍，请看后文。</p>
<p>Shebang 行不是必需的，但是建议加上这行。如果缺少该行，就需要手动将脚本传给解释器。举例来说，脚本是<code>script.sh</code>，有 Shebang 行的时候，可以直接调用执行。</p>
<pre class="line-numbers language-sh"><code class="language-sh">$ ./script.sh
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上面例子中，<code>script.sh</code>是脚本文件名。脚本通常使用<code>.sh</code>后缀名，不过这不是必需的。</p>
<p>如果没有 Shebang 行，就只能手动将脚本传给解释器来执行。</p>
<pre class="line-numbers language-sh"><code class="language-sh">$ /bin/sh ./script.sh
# 或者
$ bash ./script.sh
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-sh"><code class="language-sh"># 给所有用户执行权限
$ chmod +x script.sh

# 给所有用户读权限和执行权限
$ chmod +rx script.sh
# 或者
$ chmod 755 script.sh
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>脚本的权限通常设为<code>755</code>（拥有者有所有权限，其他人有读和执行权限）或者<code>700</code>（只有拥有者可以执行）。</p>
<p>建议在主目录新建一个<code>~/bin</code>子目录，专门存放可执行脚本，然后把<code>~/bin</code>加入<code>$PATH</code>。</p>
<pre class="line-numbers language-sh"><code class="language-sh">export PATH=$PATH:~/bin
# “ ：“(冒号)是 PATH 的分隔符（上面相当于赋值操作了）
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>上面命令改变环境变量<code>$PATH</code>，将<code>~/bin</code>添加到<code>$PATH</code>的末尾。可以将这一行加到<code>~/.bashrc</code>文件里面，然后重新加载一次<code>.bashrc</code>，这个配置就可以生效了。</p>
<pre class="line-numbers language-sh"><code class="language-sh">$ source ~/.bashrc
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>以后不管在什么目录，直接输入脚本文件名，脚本就会执行。</p>
<pre class="line-numbers language-sh"><code class="language-sh">$ script.sh
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上面命令没有指定脚本路径，因为<code>script.sh</code>在<code>$PATH</code>指定的目录中。</p>
<h2 id="source-命令"><a href="#source-命令" class="headerlink" title="source 命令"></a>source 命令</h2><p><code>source</code>命令用于执行一个脚本，通常用于重新加载一个配置文件。</p>
<pre class="line-numbers language-sh"><code class="language-sh">$ source .bashrc
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>source</code>命令最大的特点是在当前 Shell 执行脚本，不像直接执行脚本时，会新建一个子 Shell。所以，<code>source</code>命令执行脚本时，不需要<code>export</code>变量。</p>
<pre class="line-numbers language-sh"><code class="language-sh">#!/bin/bash
# test.sh
echo $foo
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>上面脚本输出<code>$foo</code>变量的值。</p>
<pre class="line-numbers language-sh"><code class="language-sh"># 当前 Shell 新建一个变量 foo
$ foo=1

# 打印输出 1
$ source test.sh
1

# 打印输出空字符串
$ bash test.sh
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面例子中，当前 Shell 的变量<code>foo</code>并没有<code>export</code>，所以直接执行无法读取，但是<code>source</code>执行可以读取。</p>
<p><code>source</code>命令的另一个用途，是在脚本内部加载外部库。</p>
<pre class="line-numbers language-sh"><code class="language-sh">#!/bin/bash

source ./lib.sh

function_from_lib
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面脚本在内部使用<code>source</code>命令加载了一个外部库，然后就可以在脚本里面，使用这个外部库定义的函数。</p>
<p><code>source</code>有一个简写形式，可以使用一个点（<code>.</code>）来表示。</p>
<pre class="line-numbers language-sh"><code class="language-sh">$ . .bashrc
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
]]></content>
      
        <categories>
            
            <category> ubuntu </category>
            
            <category> bash </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bash </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu 命令]]></title>
      <url>/ubuntu.html</url>
      <content type="html"><![CDATA[<h1 id="Ubuntu-命令"><a href="#Ubuntu-命令" class="headerlink" title="Ubuntu 命令"></a>Ubuntu 命令</h1><h2 id="1、文件-x2F-文件夹管理"><a href="#1、文件-x2F-文件夹管理" class="headerlink" title="1、文件&#x2F;文件夹管理"></a>1、文件&#x2F;文件夹管理</h2><ul>
<li><p><code>ls</code> 列出当前目录下的所有文件（不显示隐藏文件）listq</p>
</li>
<li><p><code>cd</code> 或者 <code>cd ~</code>进入用户主目录 Change Directory</p>
</li>
<li><p><code>cd -</code>返回进入此目录之前所在的目录</p>
</li>
<li><p><code>mkdir dirname</code> 新建目录 Make Directory</p>
</li>
<li><p><code>rmdir dirname</code> 删除空目录</p>
</li>
<li><p><code>rm filename</code> 删除文件Remove Directory</p>
</li>
<li><p><code>rm -rf dirname</code> 删除非空目录及其包含的所有文件</p>
</li>
<li><p><code>mv file1 file2</code>将文件1重命名为文件2</p>
</li>
<li><p><code>mv file1 dir1</code> 将文件1移动到目录1中</p>
</li>
<li><p><code>find 路径 -name “字符串”</code> 查找路径所在范围内满足字符串匹配的文件和目录</p>
</li>
<li><p><code>sudo su</code> 转到管理员权限执行命令</p>
</li>
<li><p><code>pwd</code>指出当前所在的路径。是print working directory的缩写。</p>
</li>
<li><p><code>cat</code>  查看ubuntu中文本文件的内容 concatenate</p>
</li>
<li><p><code>cat file1 file2&gt;&gt;file3</code>  把文件1和文件2的内容联合起来放到 file3中</p>
</li>
<li><p><code>su</code>   切换用户  switch user</p>
</li>
<li><p><code>ps</code>  (-auxf) 进程状态，类似于 windows 的任务管理器 process status</p>
</li>
<li><p><code>df</code>  其功能是显示磁盘可用空间数目信息及空间结点信息 disk free</p>
</li>
<li><p><code>ln -s</code> 创建一个软链接，相当于创建一个快捷方式 ink -soft </p>
</li>
<li><p><code>man</code> 命令手册 manual</p>
</li>
<li><p><code>chown</code> change owner</p>
</li>
<li><p><code>chgrp</code> change group</p>
</li>
<li><p><code>chmod</code>  change mode</p>
</li>
<li><p><code>tar</code>  tape archive</p>
</li>
<li><p>文件结尾的”rc”（如.bashrc、.xinitrc 等）：Resource configuration</p>
</li>
<li><p>c++ 文件扩展名后缀：</p>
<ul>
<li>.a（扩展名 a）：Archive，static library</li>
<li>.so（扩展名 so）：Shared object，dynamically linked library</li>
<li>.o（扩展名 o）：Object file，complied result of C&#x2F;C++ source file</li>
</ul>
</li>
<li><p>apt：Advanced package tool</p>
</li>
<li><p>| grep：Global Regular Expression Print， 全局正则表达式版本</p>
</li>
<li><p>目录：</p>
<ul>
<li>&#x2F;bin &#x3D; BInaries</li>
<li>&#x2F;dev &#x3D; Devices</li>
<li>&#x2F;etc &#x3D; Etcetera ; Editable Text Configuration, 可编辑文本配置， 便成了专门放置系统配置文件的目录</li>
<li>&#x2F;lib &#x3D; LIbrary</li>
<li>&#x2F;proc &#x3D; Processes</li>
<li>&#x2F;sbin &#x3D; Superuser Binaries</li>
<li>&#x2F;tmp &#x3D; Temporary</li>
<li>&#x2F;usr &#x3D; Unix Shared Resources</li>
<li>&#x2F;var &#x3D; Variable ?</li>
</ul>
</li>
<li></li>
</ul>
<h2 id="2、程序安装与卸载"><a href="#2、程序安装与卸载" class="headerlink" title="2、程序安装与卸载"></a>2、程序安装与卸载</h2><ul>
<li><code>chmod</code>   用于改为用户对于文件的操作权限</li>
<li><code>remove</code> 卸载指定的程序，一般最好加上“–purge”执行清除式卸载；并在程序名称后添加*号。举例：<code>sudo apt-get remove --purge nvidia*</code>  卸载 nvidia 的驱动及其配置文件</li>
<li><code>update</code> 更新本地软件源文件，需要管理员权限，举例：<code>sudo apt-get update</code></li>
</ul>
<h2 id="3、打包-x2F-解压"><a href="#3、打包-x2F-解压" class="headerlink" title="3、打包&#x2F;解压"></a>3、打包&#x2F;解压</h2><p>这里需要先解释几个参数。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
<th align="left">参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-c</td>
<td align="left">建立压缩档案</td>
<td align="left">-z</td>
<td align="left">有gzip属性的</td>
</tr>
<tr>
<td align="left">-t</td>
<td align="left">查看内容</td>
<td align="left">-j</td>
<td align="left">有bz2属性的</td>
</tr>
<tr>
<td align="left">-u</td>
<td align="left">更新原压缩包中的文件</td>
<td align="left">-Z</td>
<td align="left">有compress属性的</td>
</tr>
<tr>
<td align="left">-x</td>
<td align="left">解压</td>
<td align="left">-v</td>
<td align="left">显示所有过程</td>
</tr>
<tr>
<td align="left">-r</td>
<td align="left">向压缩归档文件末尾追加文件</td>
<td align="left">-O</td>
<td align="left">将文件解开到标准输出</td>
</tr>
</tbody></table>
<p>上表左边五个参数是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。右边五个参数是根据需要在压缩或解压时可选的。<br> 下面进行举例说明。<br> <strong>压缩</strong></p>
<ul>
<li><code>tar -cvf jpg.tar *.jpg</code> 将目录里所有jpg文件打包成tar.jpg</li>
<li><code>tar -czf jpg.tar.gz *.jpg</code>   将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz</li>
<li><code>tar -cjf jpg.tar.bz2 *.jpg</code> 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2</li>
<li><code>tar -cZf jpg.tar.Z *.jpg</code>   将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z</li>
<li><code>rar a jpg.rar *.jpg</code> rar格式的压缩，需要先下载rar for linux</li>
<li><code>zip jpg.zip *.jpg</code> zip格式的压缩，需要先下载zip for linux</li>
</ul>
<p><strong>解压</strong></p>
<ul>
<li><code>tar -xvf file.tar</code> 解压 tar包</li>
<li><code>tar -xzvf file.tar.gz</code> 解压tar.gz</li>
<li><code>tar -xjvf file.tar.bz2</code>   解压 tar.bz2</li>
<li><code>tar -xZvf file.tar.Z</code>   解压tar.Z</li>
<li><code>unrar e file.rar</code> 解压rar</li>
<li><code>unzip file.zip</code> 解压zip</li>
</ul>
<p><strong>总结</strong><br> .tar 用 tar -xvf 解压<br> .gz 用 gzip -d或者gunzip 解压<br> .tar.gz和.tgz 用 tar -xzf 解压<br> .bz2 用 bzip2 -d或者用bunzip2 解压<br> .tar.bz2用tar -xjf 解压<br> .Z 用 uncompress 解压<br> .tar.Z 用tar -xZf 解压<br> .rar 用 unrar e解压<br> .zip 用 unzip 解压</p>
<h2 id="4、用户管理"><a href="#4、用户管理" class="headerlink" title="4、用户管理"></a>4、用户管理</h2><ul>
<li><code>sudo useradd username</code> 创建一个新的用户username</li>
<li><code>sudo passwd username</code> 设置用户username的密码</li>
<li><code>sudo groupadd groupname</code> 创建一个新的组groupname</li>
<li><code>sudo usermod -g groupname username</code> 把用户username加入到组groupname中</li>
<li><code>sudo chown username:groupname dirname</code> 将指定文件的拥有者改为指定的用户或组</li>
</ul>
<h2 id="5、系统管理"><a href="#5、系统管理" class="headerlink" title="5、系统管理"></a>5、系统管理</h2><ul>
<li><code>uname -a</code> 查看内核版本</li>
<li><code>cat /etc/issue</code> 查看ubuntu版本</li>
<li><code>sudo fdisk -l</code> 查看磁盘信息</li>
<li><code>df -h</code> 查看硬盘剩余空间</li>
<li><code>free -m</code> 查看当前的内存使用情况</li>
<li><code>ps -A</code> 查看当前有哪些进程</li>
<li><code>kill 进程号</code>或者 <code>killall 进程名</code> 杀死进程</li>
<li><code>kill -9 进程号</code> 强制杀死进程</li>
</ul>
<p>设置 conda代理：</p>
<p>原本是空白文件</p>
<pre><code>sudo gedit ~/.condarc
</code></pre>
<p>在文件中添加代理端口：</p>
<pre><code>proxy_servers:
  http: http://127.0.0.1:7890
  https: https://127.0.0.1:7890
</code></pre>
]]></content>
      
        <categories>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[cmake]]></title>
      <url>/cmake.html</url>
      <content type="html"></content>
      
        <categories>
            
            <category> cmake </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title></title>
      <url>/paper/bi-ji.html</url>
      <content type="html"><![CDATA[<h2 id="置顶快捷键"><a href="#置顶快捷键" class="headerlink" title="置顶快捷键"></a>置顶快捷键</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>插入图片</td>
<td>Ctrl + Shift + I</td>
<td>插入链接</td>
<td>Ctrl + K</td>
</tr>
<tr>
<td>插入代码</td>
<td>Ctrl + Shift + K</td>
<td>插入公式</td>
<td>Ctrl + Shift + M</td>
</tr>
<tr>
<td></td>
<td></td>
<td>行内公式</td>
<td><code>$公式$</code></td>
</tr>
<tr>
<td>加粗</td>
<td>Ctrl + B</td>
<td>下划线</td>
<td>Ctrl + U</td>
</tr>
<tr>
<td>字体倾斜</td>
<td>Ctrl + I</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>无序列表</td>
<td>+ + Space</td>
<td>有序列表</td>
<td>1 + . + Space</td>
</tr>
<tr>
<td>降级列表</td>
<td>Tab</td>
<td>升级列表</td>
<td>Shift + Tab</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>创建表格</td>
<td>Ctrl + T</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="RAFT"><a href="#RAFT" class="headerlink" title="RAFT"></a>RAFT</h2><p><strong>RAFT: Recurrent All-Pairs Field Transforms for Optical Flow</strong></p>
<p><strong>2020 ECCV</strong></p>
<p><strong>创新:</strong></p>
<p>RAFT maintains and updates a single ﬁxed ﬂow ﬁeld at high resolution. This is diﬀerent from the prevailing coarse-to-ﬁne design in prior work [42,49,22,23,50], where ﬂow is ﬁrst estimated at low resolution and upsam- pled and reﬁned at high resolution. By operating on a single high-resolution ﬂow ﬁeld, RAFT overcomes several limitations of a coarse-to-ﬁne cascade: the diﬃ- culty of recovering from errors at coarse resolutions, the tendency to miss small fast-moving objects, and the many training iterations (often over 1M) typically required for training a multi-stage cascade</p>
<p>RAFT以高分辨率维护和更新单个固定流场。这不同于之前工作[42,49,22,23,50]中普遍采用的从粗到细的设计，其中首先在低分辨率下估计流量，然后在高分辨率下进行上采样和重新定义。通过在单个高分辨率流场上运行，RAFT克服了粗到细级联的几个限制：难以从粗分辨率的错误中恢复，容易错过快速移动的小对象，以及训练多级级联通常需要的多次训练迭代（通常超过1M）</p>
<h2 id="LiteFlowNet3"><a href="#LiteFlowNet3" class="headerlink" title="LiteFlowNet3"></a>LiteFlowNet3</h2><p><strong>2020 ECCV</strong></p>
<p><strong>solve:</strong></p>
<p>解决从粗到细的光流推断初始化错误问题</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Github + Hexo 搭建个人博客超详细教程]]></title>
      <url>/1.html</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li><p>作为一名计算机爱好者，摸索了一周搭建出自己的博客。目前只学    习了c语言，没有任何前端知识和网站开发经验，总的来说，算不上很难，     但也要费些心思。网上各类教程应有尽有，只要肯摸索，还是水到渠成的事。另外，写下这篇文章，记录下自己的经验，给需要的朋友，祝你早日拥有自己的博客！</p>
</li>
<li><p>搭建博客的初衷是希望用博客记录下自己的学习过程，帮助自己复习，分享一部分不成熟的思考，敦促自己把既定的目标完成。</p>
</li>
<li><p><strong>为什么要搭建自己的博客？可以看看这三篇文章：</strong></p>
</li>
</ul>
<p><a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" title="为什么你应该（从现在开始就）写博客">《为什么你应该（从现在开始就）写博客》</a>   (By 刘未鹏 | Mind Hacks)</p>
<p><a href="https://www.zhihu.com/question/19916345" title="为什么要自建博客？">《为什么要自建博客？》</a>   (By 知乎)</p>
<p><a href="https://www.cnblogs.com/jhzhu/p/3893297.html" title="我为什么写博客">《我为什么写博客》</a> （By 知明所以）</p>
<p>我们需要知道搭建博客要用到的框架。<font color=red size=3>Hexo</font>是高效的静态站点生成框架，它基于<font color=red size=3>Node.js</font>。我们使用<font color=red size=3>MarkDown</font>在本地编辑我们的博客文章，通过<font color=red size=3>Hexo</font>生成静态页面，再用两条命令即可部署到我们的网站。无需关心网页源代码的具体细节，我们只需要用心写好自己的博客内容就行。</p>
<h2 id="本文目录"><a href="#本文目录" class="headerlink" title="本文目录"></a>本文目录</h2><ul>
<li><strong>快速搭建</strong></li>
<li>安装<font color=red size=3>Node.js</font></li>
<li>添加国内镜像</li>
<li>安装<font color=red size=3>Git </font></li>
<li>注册<font color=red size=3>Github</font>账号</li>
<li>创建<font color=red size=3>Git</font>仓库</li>
<li>安装<font color=red size=3>Hexo</font> </li>
<li>配置本地<font color=red size=3>Hexo</font></li>
<li>连接<font color=red size=3>Github</font>与本地 </li>
<li>写文章、发布文章 </li>
<li><font color=red size=3>MarkDown</font>文章编辑器说明</li>
<li>配置个性化域名</li>
<li>更换自己喜欢的<font color=red size=3>Hexo</font>主题</li>
<li>我的博客源代码</li>
<li>结语</li>
</ul>
<hr>
<h1 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h1><p>有的朋友可能不想去折腾，自定义主题也比较麻烦，亦或有尝试几次搭建却失败，那就可以看这部分。快速搭建可以帮助我们更快搭建出自己的博客，优点是别人博客有的东西你都有，就跟复制差不多；缺点是博客里的配置信息都是别人的，不过不要紧，稍稍改改配置就可以。</p>
<p>在这里以我的博客为例。</p>
<h2 id="一、下载博客源代码"><a href="#一、下载博客源代码" class="headerlink" title="一、下载博客源代码"></a>一、下载博客源代码</h2><p>大家可以直接素质二连，<font color=red size=3>Star&amp;Fork</font>我的博客源代码：<a href="https://github.com/MUYIio/hexo-themes-matery">https://github.com/MUYIio/hexo-themes-matery</a>，这里我给出两种下载方法：</p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/03.png"></p>
<p><strong>第一种</strong>：直接<font color=red size=3>DownLoad</font>，下载到本地就可以。（<strong>不推荐</strong>）</p>
<p><strong>第二种</strong>：如果你已经安装了<a href="https://git-scm.com/download/win" title="Git">Git</a>，就可以右键单击<font color=red size=3>Come Bash Here</font>运行</p>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> clone git@github.com:MUYIio/hexo-themes-matery.git
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>将所有文件下载到本地，这个复杂一点。</p>
<h2 id="二、修改博客文档配置"><a href="#二、修改博客文档配置" class="headerlink" title="二、修改博客文档配置"></a>二、修改博客文档配置</h2><p>首先将我们下载的博客源代码解压，然后修改主要配置：</p>
<ul>
<li>根目录配置文件<font color=red size=3>_config.yml</font>和主题目录配置文件<font color=red size=3>_config.yml</font>中修改个人信息。</li>
<li>根目录配置文件中修改<font color=red size=3>deploy</font>一栏的<font color=red size=3>repository</font>。</li>
<li>根目录配置文件中修改<font color=red size=3>baidu_url_submit</font>一栏的<font color=red size=3>token</font>。</li>
<li>主题配置文件中修改<font color=red size=3>gitalk</font>一栏，修改方法见正文。</li>
</ul>
<p>我给出的是博客比较明显的几个地方，先修改这几个地方，其它的可以自己慢慢摸索修改。</p>
<p>最后一步，<strong>本地的运行环境还是需要搭建好的</strong>，跟着下文操作到连接Github与本地，环境就算是搭建完成。</p>
<p><strong>本地环境搭建好之后会生成的文件：</strong></p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/35.png"></p>
<p>然后直接把<font color=red size=3>Hexo</font>文件夹里面的文件删掉，把我的源代码的文件全部移动过来，就是这样了：</p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/37.png"></p>
<p>然后在<font color=red size=3>Hexo</font>文件夹下右键单击鼠标，点击 <font color=red size=3>Git Bash Here</font>点击输入以下命令上传就可以了：</p>
<pre><code>hexo clean
hexo g
hexo d
</code></pre>
<h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><p>了解一下什么是<font color=red size=3>Node.js</font>：</p>
<blockquote>
<p><font color=red size=3>Node.js</font>就是一个用于创建服务器端应用程序的运行系统，它可以轻松构建网络或其他事件驱动的应用程序服务器。</p>
</blockquote>
<p>需要用到的命令：</p>
<pre><code>$ git --version
$ node -v
$ npm -v
</code></pre>
<p><a href="https://nodejs.org/en/download/" title="Node.js">点击此处</a>进入<font color=red size=3>Node.js</font>官网下载相应版本即可，安装时选项全部默认，一路点击<font color=red size=3>Next</font>。</p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/04.png"></p>
<p>检验是否安装成功：<br>按<font color=red size=3>Win+R</font>打开命令提示符，输入<font color=red size=3>node -v</font>和<font color=red size=3>npm -v</font>，如果出现版本号，那么就安装成功了。</p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/05.png"></p>
<h1 id="添加国内镜像"><a href="#添加国内镜像" class="headerlink" title="添加国内镜像"></a>添加国内镜像</h1><p>这里我们使用阿里的国内镜像进行加速，按Win+R打开命令提示符输入：</p>
<pre><code>npm config set registry https://registry.npm.taobao.org
</code></pre>
<h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><blockquote>
<p><font color=red size=3>Git</font>是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理，帮助我们把本地网页上传到<font color=red size=3>Github</font>。</p>
</blockquote>
<p><a href="https://git-scm.com/download/win" title="Git">点击此处</a>进入Git官网下载相应版本，默认安装即可。</p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/005.png"></p>
<p>参考资料：<a href="https://www.cnblogs.com/jytx/p/5602927.html" title="如何在windows下安装GIT">《如何在windows下安装GIT》</a> (By 俊雨廷休)</p>
<p>检验是否安装成功：</p>
<p>安装完成后在命令提示符中输入<font color=red size=3>git –version</font>验证是否安装成功</p>
<pre><code>git --version
</code></pre>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/06.png"></p>
<h1 id="注册Github账号"><a href="#注册Github账号" class="headerlink" title="注册Github账号"></a>注册Github账号</h1><p><font color=red size=3>Github</font>作为全球最大的开源社区，相信朋友们都已经有了吧，如果没有，<a href="https://github.com/" title="Github">点击此处</a>进入<font color=red size=3>Github</font>官网点击 <font color=red size=3>Sign Up </font>注册账户。</p>
<h1 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h1><p>登录<font color=red size=3>Github</font>创建一个仓库</p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/07.png"></p>
<p>如下图所示，<strong>输入自己的项目名字，后面一定要加<font color=red size=3>.github.io</font>后缀，<font color=red size=3>README</font>初始化也要勾上。名称一定要和你的<font color=red size=3>Github</font>名字完全一样，比如你<font color=red size=3>github</font>名字叫<font color=red size=3>A</font>，那么仓库名字一定要是<font color=red size=3>A.github.io</font>。</strong></p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/08.png"></p>
<p>选择一个自己喜欢的主题：<br>在上面创建的仓库里面点击<font color=red size=3>Settings</font>（不是头像下面那个<font color=red size=3>Settings</font>），向下拉到最后有个<font color=red size=3>GitHub Pages</font>，点击<font color=red size=3>Choose a theme</font>选择一个主题。然后等一会儿，再回到<font color=red size=3>GitHub Pages</font>，就可以预览效果啦。</p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/09.png"></p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/10.png"></p>
<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><blockquote>
<p><font color=red size=3>Hexo</font>是一款基于<font color=red size=3>Node.js</font>的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在<font color=red size=3>GitHub</font>和<font color=red size=3>Heroku</font>上，是搭建博客的首选框架。</p>
</blockquote>
<p>选择一个磁盘，新建一个文件夹用来存放博客文件。比如我的<font color=red size=3>（C&#x2F;panakot Blog）</font>，在该文件夹下右键单击鼠标，点击<font color=red size=3> Git Bash Here</font>，输入以下<font color=red size=3> npm </font>命令即可安装</p>
<pre><code>$ npm install hexo-cli -g
</code></pre>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/11.png"></p>
<p>输入<font color=red size=3>hexo -v</font>即可检验是否安装成功，我这里就不演示了。</p>
<h1 id="配置本地hexo"><a href="#配置本地hexo" class="headerlink" title="配置本地hexo"></a>配置本地hexo</h1><p>还是在刚才新建的文件夹下再新建一个<font color=red size=3>Hexo</font>文件夹，比如我的<font color=red size=3>（C&#x2F;panakot Blog&#x2F;Hexo）</font>，在<font color=red size=3>Hexo</font>文件夹下右键单击鼠标，点击<font color=red size=3> Git Bash Here</font>，依次输入以下<font color=red size=3> npm </font>命令即可初始化。</p>
<pre><code>hexo init
npm install
</code></pre>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/12.png"></p>
<p>初始化成功生成的文件：</p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/13.png"></p>
<p>接着我们输入<font color=red size=3>hexo g</font>生成静态网页，然后输入<font color=red size=3>hexo s</font>打开本地服务器，然后浏览器打开<a href="http://localhost:4000/">http://localhost:4000/</a>，就可以预览我们的博客啦，如图：</p>
<p>显示以下信息说明操作正确：</p>
<p><code>INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code></p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/14.png"></p>
<p>按<font color=red size=3>ctrl+c</font>关闭本地服务器。</p>
<p><strong>我们以后常用到的<font color=red size=3>Hexo</font>命令：</strong></p>
<ul>
<li><p><font color=red size=3>hexo s</font>等价于 <font color=red size=3>hexo server</font>  #<font color=red size=3>Hexo</font> 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。</p>
</li>
<li><p><font color=red size=3>hexo g</font> 等价于 <font color=red size=3>hexo generate</font>  #生成静态网页 (执行 $ <font color=red size=3>hexo g</font>后会在站点根目录下生成<font color=red size=3>public</font>文件夹,<font color=red size=3> hexo</font>会将”<font color=red size=3>&#x2F;blog&#x2F;source&#x2F;</font>“ 下面的<font color=red size=3>.md</font>后缀的文件编译为<font color=red size=3>.html</font>后缀的文件,存放在”<font color=red size=3>&#x2F;blog&#x2F;public&#x2F; </font>“ 路径下)</p>
</li>
<li><p><font color=red size=3>hexo d </font>等价于 <font color=red size=3>hexo deploy</font>  #将本地数据部署到远端服务器(如<font color=red size=3>github</font>)</p>
</li>
<li><p><font color=red size=3>hexo clean </font> #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的<font color=red size=3>public</font>文件夹</p>
</li>
</ul>
<h1 id="连接Github与本地"><a href="#连接Github与本地" class="headerlink" title="连接Github与本地"></a>连接Github与本地</h1><h2 id="一、生成密钥"><a href="#一、生成密钥" class="headerlink" title="一、生成密钥"></a>一、生成密钥</h2><p>右键单击鼠标，点击 <font color=red size=3>Git Bash Here</font>输入以下命令：</p>
<pre><code>git config --global user.name &quot;Name&quot;
git config --global user.email &quot;Email&quot;
</code></pre>
<p><strong><font color=red size=3>Name</font>和<font color=red size=3>Email</font>是我们注册<font color=red size=3>Github</font>时的用户名和邮箱。</strong></p>
<p>然后生成密钥：</p>
<pre><code>ssh-keygen -t rsa -C &quot;Email&quot;
</code></pre>
<p><strong><font color=red size=3>Email</font>是我们注册<font color=red size=3>Github</font>时的邮箱</strong></p>
<p>然后会出现：</p>
<pre><code>Generating public/private rsa key pair.
Enter file in which to save the key (/c/Users/you/.ssh/id_rsa):
//到这里可以直接回车将密钥按默认文件进行存储
</code></pre>
<p>回车之后：</p>
<pre><code>Enter passphrase (empty for no passphrase):
//这里是要你输入密码，其实不需要输什么密码，直接回车就行
Enter same passphrase again:
</code></pre>
<p>接下来会有：</p>
<pre><code>Your identification has been saved in /c/Users/you/.ssh/id_rsa.
Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.
The key fingerprint is:
这里是各种字母数字组成的字符串，结尾是你的邮箱
The key&#39;s randomart image is:
这里也是各种字母数字符号组成的字符串
</code></pre>
<p>现在密钥已经生成，一般存放在<font color=red size=3>（&#x2F;c&#x2F;Users&#x2F;you&#x2F;.ssh&#x2F;id_rsa.pub.）</font>，我们运行下面的命令将密钥复制为粘贴板：</p>
<pre><code> clip &lt; ~/.ssh/id_rsa.pub
</code></pre>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/15.png"></p>
<h2 id="二、连接Github"><a href="#二、连接Github" class="headerlink" title="二、连接Github"></a>二、连接Github</h2><p>在<font color=red size=3>Github</font>头像下面点击<font color=red size=3>Settings</font>，再点击<font color=red size=3>SSH and GPG keys</font>，新建一个<font color=red size=3>SSH</font>，名字任意。</p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/16.png"></p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/17.png"></p>
<p>然后将刚才复制的密钥添加就可以了，像这样：</p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/18.png"></p>
<p><strong>本地连接Github</strong></p>
<p>右键单击鼠标，点击<font color=red size=3> Git Bash Here</font>输入以下命令，如果如下图所示，出现你的用户名，那就成功了</p>
<pre><code>ssh -T git@github.com
//注意不要做任何修改
</code></pre>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/19.png"></p>
<p>用记事本打开博客根目录下的<font color=red size=3>_config.yml</font>文件，这是博客的配置文件，我们需要修改一下才能连接<font color=red size=3>Github</font>。</p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/20.png"></p>
<p>修改最后一行的配置：</p>
<pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
  type:
</code></pre>
<p>改为：</p>
<pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
  type: git
  repository: git@github.com:panakot/panakot.github.io.git
  branch: master
</code></pre>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/21.png"></p>
<p>切记：</p>
<ul>
<li><strong><font color=red size=3>repository</font>修改为你自己的<font color=red size=3>github</font>项目地址</strong>。</li>
<li><strong>每一个冒号后面都有一个空格。</strong></li>
</ul>
<h1 id="写文章、发布文章"><a href="#写文章、发布文章" class="headerlink" title="写文章、发布文章"></a>写文章、发布文章</h1><p>首先在博客根目录下右键打开<font color=red size=3>Git Bash Here</font>输入以下命令，安装一个扩展.</p>
<pre><code>npm i hexo-deployer-git
</code></pre>
<p>然后输入下面的命令，新建一篇文章。</p>
<pre><code>hexo new post &quot;article title&quot;
</code></pre>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/22.png"></p>
<p>然后打开<font color=red size=3>C:\panakot Blog\Hexo\source_posts</font>的目录，可以发现下面多了一个文件夹和一个<font color=red size=3>.md</font>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/23.png"></p>
<p>编写完<font color=red size=3>markdown</font>文件后，根目录下右键打开<font color=red size=3>Git Bash Here</font>输入<font color=red size=3>hexo g</font>生成静态网页，然后输入<font color=red size=3>hexo s</font>可以本地预览效果，最后输入<font color=red size=3>hexo d</font>上传到<font color=red size=3>github</font>上。</p>
<p>你的博客地址：<font color=red size=3>https:&#x2F;&#x2F;你的用户名.github.io</font>，比如我的是：<a href="https://muyiio.github.io/">https://muyiio.github.io</a>，现在每个人都可以通过此链接访问你的博客</p>
<h1 id="MarkDown文章编辑器说明"><a href="#MarkDown文章编辑器说明" class="headerlink" title="MarkDown文章编辑器说明"></a>MarkDown文章编辑器说明</h1><blockquote>
<p>前面我们提到了使用<font color=red size=3>MarkDown</font>编辑我们的博客文章。<font color=red size=3> Markdown</font> 是<font color=red size=3> 2004</font> 年由 <font color=red size=3>John Gruberis </font>设计和开发的纯文本格式的语法，非常的简单实用，常用的标记符号屈指可数，几分钟即可学会，<font color=red size=3> .md </font>文件可以使用支持 <font color=red size=3>Markdown </font>语法的编辑器编辑，然后将写好的文章<font color=red size=3>（.md文件）</font>保存到<font color=red size=3> \Hexo\source_posts </font>文件夹下即可。</p>
</blockquote>
<p> <font color=red size=3>Windows </font>上推荐使用 <font color=red size=3>MarkdownPad2 </font>或者<font color=red size=3>小书匠</font>编辑器，<font color=red size=3>macOS </font>上使用<font color=red size=3> Mou</font> 编辑器，<font color=red size=3>Linux </font>上使用 <font color=red size=3>Remarkable</font> 编辑器，<font color=red size=3>Web </font>端上使用 简书。</p>
<p><strong><a href="http://markdownpad.com/download.html" title="MarkDown">点击此处</a>下载<font color=red size=3>MarkDown</font><br>，刚使用的朋友或许不知道如何使用这个编辑器，只需要几分钟就可以掌握啦，给出以下几个我觉得不错的参考：</strong></p>
<p><a href="https://www.jianshu.com/p/q81RER/" title="献给写作者的 Markdown 新手指南">《献给写作者的 Markdown 新手指南》</a> （By 简书）</p>
<p><a href="https://blog.csdn.net/u014061630/article/details/81359144?utm_source=app" title="Markdown语法图文全面详解">《Markdown语法图文全面详解(10分钟学会)》</a>（By 黑暗星球）</p>
<p><a href="https://blog.csdn.net/witnessai1/article/details/52551362?utm_source=app" title="Markdown 语法手册 （完整整理版）">《Markdown 语法手册 （完整整理版）》</a> （By witnessai1）</p>
<p><a href="https://sspai.com/post/25137" title="认识与入门 Markdown">《认识与入门 Markdown》</a>（By Te_Lee）</p>
<p>写完文章记得在博客根目录<font color=red size=3>Bash Here</font>输入<font color=red size=3>hexo g</font>和<font color=red size=3>hexo d</font>上传到网站。</p>
<h1 id="配置个性化域名"><a href="#配置个性化域名" class="headerlink" title="配置个性化域名"></a>配置个性化域名</h1><p>一顿操作下来，打开我们的博客还是：<font color=red size=3><a href="http://www.xxx.github.io/">www.xxx.github.io</a></font>，是不是很没有牌面？我们可以考虑购买一个专属域名，以后打开博客就是这样：<font color=red size=3><a href="http://www.xxx.com/">www.xxx.com</a> </font>。</p>
<p><a href="https://www.aliyun.com/" title="阿里云">阿里云</a>和<a href="https://cloud.tencent.com/" title="腾讯云">腾讯云</a>都可以，我的是腾讯云，购买域名后首先需要添加解析：</p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/24.png"></p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/25.png"></p>
<p><strong>方法一：</strong>点击添加记录，需要添加两个记录，两个记录类型都是 <font color=red size=3>CNAME </font>，第一个主机记录为<font color=red size=3> @ </font>，第二个主机记录为<font color=red size=3> www</font>，记录值都是填你自己的博客地址（比如我的是：<font color=red size=3>muyiio.github.io</font>），保存之后域名解析就完成了！</p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/27.png"></p>
<p><strong>方法二：</strong>两个记录类型为<font color=red size=3> A </font>，第一个主机记录为<font color=red size=3> @ </font>，第二个主机记录为<font color=red size=3> www</font>，记录值都为博客的<font color=red size=3> IP</font> 地址，<font color=red size=3>IP </font>地址可以<font color=red size=3> cmd</font> 中输入<font color=red size=3> ping</font> 你的博客地址 获得（比如我的：<font color=red size=3>ping muyiio.github.io</font>），保存之后域名解析就完成了！</p>
<p>参考资料：</p>
<p><a href="https://blog.csdn.net/it_man/article/details/9017307" title="域名解析中A记录、CNAME、MX记录、NS记录的区别和联系">《域名解析中A记录、CNAME、MX记录、NS记录的区别和联系》</a></p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/26.png"></p>
<p><strong>不管在哪个平台购买域名，操作都大同小异，这里说明两点</strong>：</p>
<blockquote>
<p>如果你填写的是没有<font color=red size=3>www</font>的，比如 <font color=red size=3>muyio.com</font>，那么无论是访问<font color=red size=3> <a href="https://www.muyiio.com/">https://www.muyiio.com</a> </font>还是<font color=red size=3> <a href="https://muyiio.com/">https://muyiio.com</a></font> ，都会自动跳转到<font color=red size=3> <a href="https://muyiio.com/">https://muyiio.com</a></font>。</p>
</blockquote>
<blockquote>
<p>如果你填写的是带<font color=red size=3>www</font>的，比如 <font color=red size=3><a href="http://www.muyiio.com/">www.muyiio.com</a> </font>，那么无论是访问 <font color=red size=3><a href="https://www.muyiio.com/">https://www.muyiio.com</a></font> 还是 <font color=red size=3><a href="https://muyiio.com/">https://muyiio.com</a> </font>，都会自动跳转到 <font color=red size=3><a href="http://www.imuyiio.com/">http://www.imuyiio.com</a></font>。</p>
</blockquote>
<p>然后打开你的<font color=red size=3>github</font>博客项目，点击settings，拉到下面<font color=red size=3>Custom domain</font>处，填上你自己的域名，保存就可以了。</p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/28.png"></p>
<p>现在我们的项目根目录应该会出现一个名为<font color=red size=3>CNAME</font>的文件了。如果没有的话，打开你本地博客<font color=red size=3>&#x2F;source</font>目录，我的是<font color=red size=3>C:\Blog\Hexo\source</font>，新建<font color=red size=3>CNAME</font>文件，<font color=red size=3>（注意不要加.txt，没有任何后缀名！）</font>。然后在里面写上你的域名，保存。最后运行<font color=red size=3>hexo g、hexo d</font>上传到<font color=red size=3>github</font>。</p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/29.png"></p>
<p>现在就可以通过我们的个性化域名：<font color=red size=3><a href="http://www.xxx.com、xxx.com/">www.xxx.com、xxx.com</a></font>访问自己的博客了。</p>
<h1 id="更换自己喜欢的Hexo主题"><a href="#更换自己喜欢的Hexo主题" class="headerlink" title="更换自己喜欢的Hexo主题"></a>更换自己喜欢的Hexo主题</h1><p>点击进入<a href="https://hexo.io/themes/" title="Hexo主题专栏">Hexo主题专栏</a>可以看到很多<font color=red size=3>Hexo</font>主题：</p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/30.png"></p>
<p>推荐：</p>
<p><a href="https://blog.csdn.net/fail_perfectly/article/details/83791781?utm_source=app" title="几个好用的hexo主题">几个好用的hexo主题</a> (By fail_perfectly)</p>
<p>这里我们以<a href="http://huangxuan.me/" title="Bean Tech">Bean Tech</a>主题为例，下滑到底部我们可以看到他的<font color=red size=3>GitHub</font>（<font color=red size=3>有的主题是：Theme by xxx，点击那里也是进入GitHub地址</font>）：</p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/31.png"></p>
<p>点击进入主题的<font color=red size=3>GitHub</font>地址：</p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/32.png"></p>
<p>复制该项目地址：</p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/33.png"></p>
<p>然后打开<font color=red size=3> Hexo </font>文件夹下的<font color=red size=3> themes</font> 目录（如：<font color=red size=3>C:\MUYIio Blog\Hexo\themes</font>），右键<font color=red size=3> Git Bash Here</font>，输入以下命令：</p>
<pre><code>$ git clone 此处填写你刚才复制的主题地址
</code></pre>
<p>以我们刚才复制的为例：</p>
<pre><code>$ git clone https://github.com/Huxpro/huxpro.github.io
</code></pre>
<p>下载完成后即可在<font color=red size=3> themes </font>目录下生成 <font color=red size=3>hexo-theme-Bean-Tech </font>文件夹，然后打开 <font color=red size=3>Hexo</font> 文件夹下的配置文件 <font color=red size=3>_config.yml </font>，找到关键字 <font color=red size=3>theme</font>，修改参数为：<font color=red size=3>theme：hexo-theme-Bean-Tech </font>（其他主题修改成相应名称即可），<strong>再次注意冒号后面有一个空格！</strong></p>
<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/34.png"></p>
<p>现在我们的主题已经替换完成，将它部署到我们的博客，博客根目录下右键<font color=red size=3> Git Bash Here</font>，输入以下命令：</p>
<pre><code>hexo clean
hexo g
hexo d
</code></pre>
<p>现在访问我们的网站就可以看到主题已经更换了，但是比如网站标题，图标等都没有更换，我们博客文件中有两份主要的配置文件，名称都是 <font color=red size=3>_config.yml</font> ，它们均是用于站点配置使用的。其中，一份位于站点根目录下（比如我的：<font color=red size=3>C:\MUYIio Blog\Hexo_config.yml</font>），主要包含<font color=red size=3> Hexo</font> 本身整站的配置；另一份位于主题目录下（比如我的：<font color=red size=3>C:\MUYIio Blog\Hexo\themes\hexo-theme-matery_config.yml</font>），这份配置由主题作者提供，主要用于配置主题相关的选项，一般<font color=red size=3> _config.yml </font>文件里都有相关注释，按需修改即可。</p>
<h1 id="我的博客源代码"><a href="#我的博客源代码" class="headerlink" title="我的博客源代码"></a>我的博客源代码</h1><p><strong>我的博客源代码地址：<a href="https://github.com/MUYIio/hexo-themes-matery">https://github.com/MUYIio/hexo-themes-matery</a>，有心的话可以给个<font color=red size=3>Star&amp;Fork</font>。</strong></p>
<p>下载源代码：git clone <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#109;">&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#109;</a>:MUYIio&#x2F;hexo-themes-matery.git</p>
<p>在文章开头给出了快速搭建教程，相对于自己从头开始搭建还是比较方便的，修复了很多<font color=red size=3>Bug</font>，也添加了一些插件，下载就可以使用，可以帮你们省去个性化配置带来的很多麻烦。</p>
<p>主题的原地址在这里：<a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a>，作者把文档写得也非常的详细，还有中英文两个版本，建议可以多看几遍，在本地修改的时候轻松一些。</p>
<p>使用我的源代码之前本地的环境还是要搭建好，就是前面一部分。</p>
<table><tr><td bgcolor=orange>
-----------------------------------------------------------------------------------------------------------                                                                                                                                                                                                            
</td></tr></table>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>初学者可能会觉得困难，毕竟很多东西都是第一次接触，当初我也尝试了好几次才成功，不要放弃，弄错了就删掉重新来过，当你把博客搭建出来会觉得受益良多的。</p>
<p>文章中难免有错误的地方，有大佬发现了欢迎给我指正！有的地方解释不够详细，可以百度一下看看细节，文章中的引用以及参考资料涉及侵权请联系我删除！</p>
]]></content>
      
        <categories>
            
            <category> Blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Github </tag>
            
            <tag> Hexo </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
